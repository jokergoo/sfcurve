---
title: "Generalized Peano Curve"
author: "Zuguang Gu (z.gu@dkfz.de)"
date: '`r Sys.Date()`'
output: 
  html_document:
    self_contained: true
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
---

```{r, echo = FALSE}
library(knitr)

knitr::opts_chunk$set(
    error = FALSE,
    tidy  = FALSE,
    message = FALSE,
    warning = FALSE,
    fig.align = "center")

library(grid)
library(sfcurve)
```


## Base patterns

There are the following expansion rules from level-0 to level-1 for the Peanno curve.

```{r, fig.width = 4.5, fig.height = 4.5}
draw_rules_peano()
```

`I` and `J` are the same on level-0 (i.e. going forward), but they correspond to different
patterns on level-1 as we only allow a pattern to rotate, but not to flip. Also separating
`I` from `J` makes only one extension from level-0 to level-1 for each base pattern.

Unlike the Hilbert curve where there are more than one transverse paths. For the Peano
curve, we can simpliy specify the number of the level.

```{r}
p = sfc_peano("I", level = 3)
# the same as sfc_peano("I", code = "111")
plot(p)
```

By applying the expansion rules, a Peano curve is fixed on a level $k$. However, note each level-1 or level-$k$ ($k \ge 1$) pattern
can be flipped against its diagonal line without affecting the structure of other parts in the curve. Then we can have a flipped version of the original expansion rules:

```{r, fig.width = 4.5, fig.height = 4.5}
draw_rules_peano(flip = TRUE)
```

Then, for example, when expanding $I^{(0)}$ to $I^{(1)} = RI^{(270)}L^{(270)}LJ^{(90)}R^{(90)}RI^{(270)}L^{(270)}$,
each base pattern can take its flipped version independently.

## Number of different forms

From level 0 to level 1, there are two different forms: the normal one and the flipped one:

$$
n_1 = 2
$$

From level 1 to level 2, all the nine points can be expanded by choosing the normal base pattern
or the flipped one. The global unit on level 2 can also be in the normal form or the flipped form.

$$
n_2 = n_1^9 \cdot 2
$$

Then we can have sequentially:

$$
\begin{align*}
n_3 &= n_2^9 \cdot 2 \\
    & ... \\
n_k &= n_{k-1}^9 \cdot 2 \\
\end{align*}
$$

And $n_k$ can be calculated as:

$$
n_k = 2^{9^{k-1} + ... + 9 + 1} = 2^{\frac{9^k - 1}{8}}
$$

Or we can also count the total number of square units on various levels. For a curve with level $k$, the number
of square unit with level $i$ is $9^{k-i}$. Then we sum these numbers from level $k$ to level 1:

$$
\sum_{i=1}^{k} 9^{k-i} = \frac{9^k - 1}{8}
$$

Each unit on various levels all can be flipped independently. The final number of different
forms of the Peano curve on level $k$ is:

$$
n_k = 2^{\frac{9^k - 1}{8}}
$$

With combining the four base patterns and four rotations, the final number of different forms of
the Peano curve is 

$$
4 \cdot 4 \cdot 2^{\frac{9^k - 1}{8}}
$$

## Unit flipping 

We can set a global flipping rule on every level of expansion.

```{r}
sfc_peano("I", level = 3, 
    flip = c(FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)) |> plot()

```

Every unit can be manually flipped by specifying its "hierarchical index". Here "93" means the third level-1 subunit
of the 9th level-2 subunit. Notice the orientation of the top-left corner of the top-right block in the right plot.

```{r, fig.width = 8, fig.height = 4}
draw_multiple_curves(
    p,
    sfc_flip_unit(p, "93"),
    nrow = 1
)
```

## The standard Peano curve

There are two ways to generate the standard Peano curve where all level-1 (9x9) unit
are oriented vertically.

First, notice taking the normal expansion rules, if splitting the curves into three parts
euqally, the first subunit in the second and the third parts are flipped. Then we just need
to flipped these two back. Note such flipping should be applied on all levels.

In the following, `flip` can be set to a function accepting an argumnt `n` which is the number
of base patterns on current level in the expansion. The self-defined function returns
a logical vector with the same length as `n`, representing whether using the flipped rules.

```{r}
sfc_peano("I", level = 3, flip = function(n) {
    if(n == 1) {
        return(FALSE)
    }
    l = rep(FALSE, n)
    portion = 1
    while(portion*9 <= n) {
        ind = ((1:(n/3/portion))*3*portion)[rep(c(TRUE, TRUE, FALSE), n/9/portion)]
        l[ind + 1] = TRUE
        portion = portion*9
    }
    l
}) |> plot()
```

Second, we can mandatorily change all level-1 units to vertical. `sfc_apply()` applied
a self-defined function `fun` on every units on a certain level (in the following example,
it is applied to level `sfc_level(p)-1`). The self-defined function accepts one argument
`x` which is the current subunit.

```{r}
sfc_apply(p, sfc_level(p) - 1, function(x) {
    if(level1_unit_orientation(x) == "horizontal") {
        sfc_flip_unit(x)
    } else {
        x
    }
}) |> plot()
```

Or use the helper function `change_level1_unit_orientation()`.

```{r}
change_level1_unit_orientation(p, to = "vertical") |> plot()
```

## General Peano curve

For the curve on level $k$, the subunits, higher levels can be randomly flippped, 
while only make sure all the level-1 subunit are vertical.

`p` can be a level-$k$ curve with subunits on any level flipped.

```{r, fig.width = 7.5, fig.height = 2.5}
p2 = sfc_flip_unit(p, "") |> sfc_flip_unit("7") |> 
    change_level1_unit_orientation(to = "vertical")
p3 = sfc_flip_unit(p, "1") |> 
     sfc_flip_unit("2") |> 
     sfc_flip_unit("3") |> 
     sfc_flip_unit("4") |> 
     sfc_flip_unit("5") |> 
     sfc_flip_unit("6") |> 
     sfc_flip_unit("7") |> 
     sfc_flip_unit("8") |> 
     sfc_flip_unit("9") |> 
     change_level1_unit_orientation(to = "vertical")
draw_multiple_curves(p, p2, p3, 
    nrow = 1, title = FALSE)
```

We can also do from $k-1$ level, i.e. generate an curve on $k-1$ of any form,
extend it to level $k$ and adjust all level-1 units to vertical.

```{r}
p2 = sfc_peano("I", level = 2)
sfc_expand(p2) |>  # expand from level 2 to level 3
    change_level1_unit_orientation(to = "vertical") |> 
    plot()
```

## Other structures

By manually flipping the units on various level, we can generate more patterns.
For example, in the following 9 blocks, we let the even blocks to be all vertical
and odd blocks to be all horizontal. Here the self-defined function can accepts
a second argument which is the index of the current unit.

```{r}
p2 = change_level1_unit_orientation(p, to = "vertical")
sfc_apply(p2, sfc_level(p2) - 2, function(x, i) {
    if(i %% 2 == 1) {
        sfc_flip_unit(x)
    } else {
        x
    }
}) |> plot()
```

## Seed as a sequence


```{r, fig.width = 3, fig.height = 3}
seed = sfc_sequence("IJILJILJILJI", rot = -90, universe = sfc_universe(SFC_RULES_PEANO))
plot(seed, grid = TRUE)
```

```{r, fig.width = 6, fig.height = 6}
sfc_peano(seed, code = "111") |> plot(lwd = 2)
```

