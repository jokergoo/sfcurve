[{"path":"/articles/all_3x3_curve.html","id":"base-patterns","dir":"Articles","previous_headings":"","what":"Base patterns","title":"3x3 Curve","text":"can merge base patterns Peano curve Meander curve construct universe set base patterns general 3x3 space-filling curves. Please note, base patterns Peano curve contain “vertical” patterns, Meander curve contain “forward” pattenrs (major rules two types curves). “Horizontal” “backward” patterns can obtained flipping.  Note, J Peano curve put base group. vertical Peano patterns can also expanded B/D/P/Q/C bases.","code":"draw_rules_3x3_combined()"},{"path":"/articles/all_3x3_curve.html","id":"transverse-path","dir":"Articles","previous_headings":"","what":"Transverse path","title":"3x3 Curve","text":"Since now Peano base units Meander base units included, transverse paths level \\(k\\) level \\(k+1\\) massive. Let’s try expand \\(I_1^{(1)}\\) next level. following plot shows transverse paths sequence (0)(0)R(0)R(270)(180)L(180)L(270)(0)(0) level 2.  numbers total transverse paths level-1 base patterns: Peano curve, level-1 patterns corner values (1, 1) (2, 2). following, can see Peano curve one specific transverse path level \\(k\\).  Meander curve, corner values always (1, 2) (2, 1). always two transverse paths given \\(k\\). transverse code first base pattern determined, whole transverse path fixed.","code":"p = SFC_RULES_3x3_COMBINED@rules$I[[3]] p ## A sequence of 9 base patterns. ##   I(0)I(0)R(0)R(270)  I(180)L(180)L(270)I(0) ##   I(0) pl = all_transverse_paths(SFC_RULES_3x3_COMBINED, p) length(pl) ## [1] 400 plot_transverse_paths(SFC_RULES_3x3_COMBINED, p) for(b in c(\"I\", \"R\", \"L\", \"U\", \"B\", \"D\", \"P\", \"Q\", \"C\")) {     for(i in seq_along(SFC_RULES_3x3_COMBINED@rules[[b]])) {         pl = all_transverse_paths(             SFC_RULES_3x3_COMBINED,              SFC_RULES_3x3_COMBINED@rules[[b]][[i]])         cat(b, \"_\", i, \": \", length(pl), \"\\n\", sep = \"\")     } } ## I_1: 216 ## I_2: 216 ## I_3: 400 ## I_4: 400 ## R_1: 288 ## R_2: 153 ## R_3: 300 ## L_1: 153 ## L_2: 288 ## L_3: 300 ## U_1: 204 ## U_2: 204 ## B_1: 216 ## B_2: 153 ## B_3: 300 ## D_1: 153 ## D_2: 216 ## D_3: 300 ## P_1: 228 ## P_2: 171 ## P_3: 300 ## Q_1: 228 ## Q_2: 171 ## Q_3: 300 ## C_1: 171 ## C_2: 171 ## C_3: 225 ## C_4: 225 plot_transverse_paths(SFC_RULES_3x3_COMBINED, p, type = \"11|22\") plot_transverse_paths(SFC_RULES_3x3_COMBINED, p, type = \"12|21\")"},{"path":"/articles/all_3x3_curve.html","id":"number-of-different-forms","dir":"Articles","previous_headings":"","what":"Number of different forms","title":"3x3 Curve","text":"Let’s make assumption: general 3x3 curve expands level \\(k\\) \\(n\\) points (\\(n = 9^{k}\\)) level \\(k+1\\), total number transverse paths denoted \\(t_k\\) : \\[ t_k \\approx \\alpha^n \\] Since 3x3 curve, base patterns either three four transverse codes, let’s consider sequence \\(n\\) base patterns \\(\\). Let’s start first base pattern. second one, base pattern can connect two following base patterns (e.g. (1, 1) position 1 can connect (2, 1) (2, 2)), total number transverse paths fixed position 1 \\(2^{n-1}\\). taking four base patterns position 1, final number transverse paths \\(n\\) base patterns \\(4 \\cdot 2^{n-1} = 2 \\cdot 2^n\\), possible maximal number total transverse paths sequence length \\(n\\). \\[ \\begin{align*} \\alpha^{n} &= 2 \\cdot 2^n \\\\ \\alpha &= 2 \\cdot 2^{1/n} \\\\ \\end{align*} \\] Normally \\(n\\) huge, results : \\[ \\alpha_\\mathrm{max} \\approx 2 \\] minimal case, one transverse path \\(n\\) base patterns, thus \\[\\alpha_\\mathrm{min} = 1\\] \\(\\alpha\\) approximately number 1 2. Next let’s calculate number different forms 3x3 curve level: \\[ \\begin{align*} n_1 &= n_0 \\\\ n_2 &= n_1 \\cdot t_1  = n_1 \\cdot \\alpha_1^{9^1}\\\\     & ... \\\\ n_k &= n_{k-1} \\cdot t_{k-1}  = n_{k-1} \\cdot \\alpha_{k-1}^{9^{k-1}}\\\\ \\end{align*} \\] can calculate \\(n_k\\) \\[ n_k = n_0 \\cdot \\alpha_1^{9^1} \\cdot \\alpha_2^{9^2} ... \\alpha_{k-1}^{9^{k-1}}  \\] approximately take \\(\\alpha_i\\) similar: \\[ n_k \\approx n_0 \\cdot \\alpha^{\\frac{9^k -9}{8}} \\] \\(n_0 = 3\\) \\(n_0 = 4\\). also considering 9 flipped rules 4 rotations, unit different level can flipped (vertically/horizontally/diagonal) independently, final number possible forms 3x3 curves approximate \\[ 9 \\cdot 4 \\cdot n_0 \\cdot \\alpha^{\\frac{9^k -9}{8}} \\cdot 2^{\\frac{9^k - 1}{8}} \\]","code":""},{"path":"/articles/all_3x3_curve.html","id":"curves","dir":"Articles","previous_headings":"","what":"Curves","title":"3x3 Curve","text":"sfc_3x3_combined() generates curve level, transverse path randomly selected.","code":"draw_multiple_curves(     sfc_3x3_combined(\"I\", level = 3),     sfc_3x3_combined(\"I\", level = 3),     sfc_3x3_combined(\"I\", level = 3),     sfc_3x3_combined(\"I\", level = 3),     nrow = 2 )"},{"path":"/articles/functions.html","id":"functions","dir":"Articles","previous_headings":"","what":"Functions","title":"Functions/Classes","text":"lists major high-level functions implemented package.","code":""},{"path":"/articles/functions.html","id":"make-curves","dir":"Articles","previous_headings":"Functions","what":"Make curves","title":"Functions/Classes","text":"Make general curves: sfc_hilbert(), sfc_peano(), sfc_meander(), sfc_h(). Make curves standard forms: hilbert_curve(), moore_curve(), beta_omega_curve(), peano_curve(), meander_curve(), h_curve(). curves: sfc_3x3_combined(), sfc_4x4_meander(), hilbert_3d(). Generate nxn curves based specific level-1 units: sfc_generator()","code":""},{"path":"/articles/functions.html","id":"expansion-rules","dir":"Articles","previous_headings":"Functions","what":"Expansion rules","title":"Functions/Classes","text":"Pre-defined expansion rules: SFC_RULES_HILBERT, SFC_RULES_PEANO, SFC_RULES_MEANDER, SFC_RULES_3x3_COMBINED, SFC_RULES_4x4_MEANDER_1, SFC_RULES_4x4_MEANDER_2. Draw rules: draw_rules_hilbert(), draw_rules_peano(), draw_rules_meander(), draw_rules_3x3_combined(), draw_rules_4x4_meander().","code":""},{"path":"/articles/functions.html","id":"unit-flipping","dir":"Articles","previous_headings":"Functions","what":"Unit flipping","title":"Functions/Classes","text":"sfc_apply(), unit_orientation(), sfc_flip_unit(), level1_unit_orientation(), change_level1_unit_orientation().","code":""},{"path":"/articles/functions.html","id":"coordinates-of-segments","dir":"Articles","previous_headings":"Functions","what":"Coordinates of segments","title":"Functions/Classes","text":"sfc_segments()","code":""},{"path":"/articles/functions.html","id":"classes","dir":"Articles","previous_headings":"","what":"Classes","title":"Functions/Classes","text":"following classes defined: sfc_sequence: general class sequence letters. sfc_seed: essentially sfc_sequence. class used mark representing object can used seed generating curves. sfc_unit: used constructing expansion rules. sequence level-1 curve. also additional slot corner corresponds corners -direction square level-1 unit. sfc_nxn: base class general nxn curves. sfc_hilbert, sfc_peano, sfc_meander, sfc_3x3_combined, sfc_meander_4x4 child classes sfc_nxn. Specifically sfc_meander_4x4 two child classes sfc_meander_4x4_1 sfc_meander_4x4_2 using two different sets expansion rules. following two classes define curve expanded: sfc_base: base patterns (.e. level-0). defines previous point next points sfc_rules: contains expansion rules level-0 level-1. UML classes corresponding methods implemented package (made nomnoml).","code":""},{"path":"/articles/h_curve.html","id":"construction-and-expansion","dir":"Articles","previous_headings":"","what":"Construction and expansion","title":"H-Curve","text":"H-curve following two base units: H-shape unit \\(H_1\\) rotated version \\(H_2\\):  recursively expand higher levels, can replace four corners (corner represented 2x2 grids) full H-units. can also copy-paste way put four copies H-unit four quadrants connect 1-2-3-4 order following figure:  connect two units, corners corresponding units need opened. Take unit 1 example, connects unit 2 via topright corner, two ways open corner: open horizontal segment vertical segment (red blue segments). process similar unit 2-4. name openning horizontal segment \"h\" openning vertical segment \"v\". See next two plots:  , denote \\(H^{(0)}\\) base unit H-curve, \\(H^{(1)}\\) H-curve first iteration. can following expansion rule: \\[ H^{(1)} = H^{(0)} \\cdot c \\cdot H^{(0)} \\cdot c \\cdot H^{(0)} \\cdot c \\cdot H^{(0)} \\cdot c, \\quad c \\\\{h, v\\} \\] four \\(H^{(0)}\\) order 1-2-3-4, \\(c\\) action two units connected takes values \\(h\\) (open horiozntal segment) \\(v\\) (open vertical segment). fourth \\(H^{(0)}\\) connects back first \\(H^{(0)}\\). two types base units H-curve: \\(H_1\\) \\(H_2\\), four \\(H^{(0)}\\) actually can differently independently selected. can change previous equation : \\[ H^{(1)} = H_1^{(0)} \\cdot c \\cdot H_2^{(0)} \\cdot c \\cdot H_3^{(0)} \\cdot c \\cdot H_4^{(0)} \\cdot c, \\quad H_i^{(0)} \\\\{H_1, H_2\\}, \\\\{1..4\\}\\] next plots show forms H-curves first iteration, connection method “h”:  generally, can generalize previous equation step iteration \\(k\\): \\[ H^{(k)} = H_1^{(k-1)} \\cdot c \\cdot H_2^{(k-1)} \\cdot c \\cdot H_3^{(k-1)} \\cdot c \\cdot H_4^{(k-1)} \\cdot c, \\quad k \\ge 1\\]","code":"draw_multiple_curves(H1, H2, nrow = 1, closed = TRUE) draw_multiple_curves(     sfc_h(H1, iteration = 1, connect = \"h\"),     sfc_h(H1, iteration = 1, connect = \"v\"),     closed = TRUE, nrow = 1 ) draw_multiple_curves(     expand_h(H1, H1, H1, H1), expand_h(H1, H1, H1, H2), # \"h\" is the default     expand_h(H1, H1, H2, H1), expand_h(H1, H1, H2, H2),     expand_h(H1, H2, H1, H1), expand_h(H1, H2, H1, H2),     expand_h(H1, H2, H2, H1), expand_h(H1, H2, H2, H2),     expand_h(H2, H1, H1, H1), expand_h(H2, H1, H1, H2),     expand_h(H2, H1, H2, H1), expand_h(H2, H1, H2, H2),     expand_h(H2, H2, H1, H1), expand_h(H2, H2, H1, H2),     expand_h(H2, H2, H2, H1), expand_h(H2, H2, H2, H2),     nrow = 2, closed = TRUE )"},{"path":"/articles/h_curve.html","id":"number-of-different-forms","dir":"Articles","previous_headings":"","what":"Number of different forms","title":"H-Curve","text":"first iteration, total number forms H-curve denoted \\(n_1\\) \\[ n_1 = n_0^4 \\cdot 2 \\] \\(n_0\\) number different forms base patterns, 2. second 2 number connection method, .e. “h” “v”. Similally, can write numbers forms iterations: \\[ \\begin{align*} n_2 &= n_1^4 \\cdot 2 \\\\ n_3 &= n_2^4 \\cdot 2 \\\\  & ... \\\\ n_k &= n_{k-1}^4 \\cdot 2\\\\ \\end{align*} \\] can number different forms H-curve iteration \\(k\\), taking \\(H_1\\) \\(H_2\\) base units: \\[ n_k = 2^{4^k + 4^{k-1} + ... + 4 + 1} = 2^{\\sum_{=0}^k{4^}} =  2^{\\frac{4^{k+1}-1}{3}}  \\] shows iteration \\(k\\), form can assigned unique sequence binary bits length \\((4^{k+1}-1)/3\\).","code":""},{"path":"/articles/h_curve.html","id":"more-general-forms","dir":"Articles","previous_headings":"","what":"More general forms","title":"H-Curve","text":"generally, \\(H_1\\) \\(H_2\\) can thought built even smaller unit \\(H_0\\): \\[ \\begin{align*} H_1 &= H_0 \\cdot h \\cdot H_0 \\cdot h \\cdot H_0 \\cdot h \\cdot H_0 \\cdot h \\\\ H_2 &= H_0 \\cdot v \\cdot H_0 \\cdot v \\cdot H_0 \\cdot v \\cdot H_0 \\cdot v \\\\ \\end{align*} \\]  Also connection methods four units necessary . followng example, take \\(H_0\\) base unit take vhvh connection methods, .e. vertical segment first unit, horizontal segment second unit, vertical segment third unit horizontal segment fourth segment opened, five iterations:","code":"draw_multiple_curves(     H0,      expand_h(H0, connect = \"h\"),     expand_h(H0, connect = \"v\"),     closed = TRUE, nrow = 1 ) fun = function(h, iteration) {     for(i in 1:iteration) h = expand_h(h, connect = \"vhvh\")     h } fun(H0, 5) |> plot_segments(closed = TRUE)"},{"path":"/articles/h_curve.html","id":"global-structure-is-unchanged","dir":"Articles","previous_headings":"","what":"Global structure is unchanged","title":"H-Curve","text":"Although H-curve large number different forms, different settings affect folding locally curve, global structure still unchanged:  next plots show distances points indicies two random H-curves, normalized “sizes” curves. can see distance difference small.","code":"p1 = sfc_h(H1, iteration = 3, random = TRUE) p2 = sfc_h(H1, iteration = 3, random = TRUE) p3 = sfc_h(H1, iteration = 5, random = TRUE) p4 = sfc_h(H1, iteration = 5, random = TRUE) draw_multiple_curves(p1, p2, p3, p4, nrow = 2) par(mfrow = c(2, 1)) d1 = sqrt((p1[, 1] - p2[, 1])^2 + (p1[, 2] - p2[, 2])^2)/sqrt(nrow(p1)) plot(d1, type = \"h\", main = \"iter = 3\", xlab = \"Sequential points on H-curve\", ylab = \"distance\")  d2 = sqrt((p3[, 1] - p4[, 1])^2 + (p3[, 2] - p4[, 2])^2)/sqrt(nrow(p3)) plot(d2, type = \"h\", main = \"iter = 5\", xlab = \"Sequential points on H-curve\", ylab = \"distance\")"},{"path":"/articles/hilbert_curve.html","id":"base-patterns","dir":"Articles","previous_headings":"","what":"Base patterns","title":"Generalized Hilbert Curve","text":"space-filling curve can generated recursively repeating certain patterns sub-structures. Thus, define following expansion rules level 0 level 1. patterns level 0 called base patterns contains single points -direction -direction.  example, base pattern \\(\\) level 0, explicitly denoted \\(^{(0)}\\). expands level 1 keeping direction curve, two options listed diagram. example , choose first option. Now following expansion: \\[ ^{(0)} \\rightarrow ^{(1)}_1 \\]  can describe curve generation four steps: step 1. bottom , right . base pattern \\(R\\) without rotation, thus denote \\(R^{(0)}\\), step 2. left , top . base pattern \\(L\\) -90 degrees clockwise rotation, thus denote \\(L^{(0),-90}\\) \\(L^{(0),270}\\), step 3. bottom , left . base pattern \\(L\\) without rotation, denote \\(L^{(0)}\\), step 4. right , top . step can denoted \\(R^{(0),90}\\). expansion can written sequence four base patterns: \\[ ^{(1)}_1 = R^{(0)}L^{(0),90}L^{(0)}R^{(0),270} \\] knowing -direction -direction base patterns, shape \\(^{(1)}_1\\) can determined. diagram, notation levels removed since can easily identified. \\[ I_1 = RL^{90}LR^{270} \\] base pattern defines -direction determines location next point, thus, long “actions” base patterns sequence known (.e. going left right), form sequence fixed. words, rotation first base pattern determines final form sequence fixed, rotations remaining base patterns fixed can automatically calculated. However still explicitly add rotations base patterns (except rotations zero) since also need deal segments curves package. later sections vignettes, sometimes also call base patterns base letters convinience.","code":"draw_rules_hilbert()"},{"path":"/articles/hilbert_curve.html","id":"rotate","dir":"Articles","previous_headings":"","what":"Rotate","title":"Generalized Hilbert Curve","text":"set rotation base patterns shapes listed diagram zero (.e. base state. course convinience). can easily define rotation base pattern sequence base patterns. Denote \\(X^\\theta\\) base pattern \\(X \\\\{, R, L, U, B, D, P, Q, C\\}\\), \\(\\theta\\) rotation regarding base state diagram, \\(\\theta \\\\{0, 90, 180, 270\\}\\) positive \\(\\theta\\) corresponds reverse clockwise rotation, \\[ (X^{\\theta_1})^{\\theta_2} = X^{\\theta_1 + \\theta_2} \\] means rotating pattern twice identical rotating pattern sum two rotations. Note \\[ X^\\theta = X^{\\theta \\bmod 360} \\] Rotating sequence base patterns identical rotating individual base patterns sequence. \\[ (X_1^{\\theta_1}X_2^{\\theta_2}...X_n^{\\theta_n})^\\theta  = X_1^{(\\theta_1 + \\theta)}X_2^{(\\theta_2 + \\theta)} ... X_n^{(\\theta_n + \\theta)} \\] also including four rotations base patterns, diagram contains complete set expansions level 0 level 1 2x2 curve.","code":""},{"path":"/articles/hilbert_curve.html","id":"expand-the-curve","dir":"Articles","previous_headings":"","what":"Expand the curve","title":"Generalized Hilbert Curve","text":"diagram defines expansion curve level 0 level 1 (0--1 expansion), already enough generating curve level k. simplicity, take curve initialized single base pattern example. expansion process can described following steps: level 0 -> level 1, \\(P_1 = (X_i)_4\\). generates level 1 curve 4 base patterns. level 1 -> level 2, \\(P_2 = (X_i)_{16}\\). base pattern \\(P_1\\), replace level 1 expansion. generates curve \\(4^2\\) base patterns. level k-1 -> level k, \\(P_k = (X_i)_{4^k}\\). Note curve level k-1 \\(P_{k-1}\\) already represented sequence \\(4^{k-1}\\) base patterns. base pattern \\(P_{k-1}\\), replace level 1 expansion. generates curve \\(4^k\\) base patterns. \\(P_i\\) curve unit level . can see, expand curve level k step step, need use expansions level 0 level 1. One problem arises expanding base pattern level unit. shown diagram, expansion level 0 level 1, base pattern two types expansion, thus need criterion select proper one make sure points correctedly connected final curve. first step single base pattern expands four base patterns, level 1 unit can ensured connected. However, second step four base patterns expand 16 base patterns, .e. level 1 level 2, need make sure 16 base patterns connected corrected way, .e. straight, left right. Let’s rewrite \\(P_1\\) sequence four base patterns: \\[ P_1 = X_1 X_2 X_3 X_4 \\] e.g. base pattern \\(X_1\\) expands level 1 denoted \\(X^{(1)}_{<>,1}\\) (\\(=1\\) \\(=2\\)), \\(P_2\\) : \\[ P_2 = X^{(1)}_{<i_1>,1} X^{(1)}_{<i_2>,2} X^{(1)}_{<i_3>,3} X^{(1)}_{<i_4>,4} \\] four \\(X^{(1)}_{<>,1}\\) represents four 2x2 grids. need criterion selecting \\(\\) level 1 unit make sure level 1 units curve properly connected. curve level k contains \\(4^{k-1}\\) 2x2 units expanded curve level k-1. Thus, successful method can ensure \\(4^{k-1}\\) 2x2 units properly connected makes final curve correct form.","code":""},{"path":"/articles/hilbert_curve.html","id":"corners","dir":"Articles","previous_headings":"Expand the curve","what":"Corners","title":"Generalized Hilbert Curve","text":"level 1 units transverse \\(2 \\times 2\\) grids, thus square-shape -direction -direction. Denote bottom left top right value 1 top left bottom right value 2:  define corner value \\(\\tau\\) level 1 unit \\(X^{(1)}\\) 2-tuple \\((c_1, c_2)\\) \\(c_1\\) value entering corner \\(c_2\\) value leaving corner \\(X^{(1)}\\): \\[ \\tau_{X^{(1)}} = (c_1, c_2), \\quad c_1, c_2 \\\\{1, 2\\} \\] diagram, 2x2 unit defined , either \\(\\tau_{X^{(1)}} = (1, 2)\\) \\(\\tau_{X^{(1)}} = (2, 1)\\). define complement \\(c\\) \\[ \\hat{c} = \\left\\{\\begin{matrix} 2 & \\text{}c = 1,\\\\  1 & \\text{}c = 2,\\\\  \\end{matrix}\\right. \\] Rotating \\(X^{(1)}\\) 90 degrees (multiples, either clockwise reverse clockwise) changes order two values tuple, rotating 180 degrees (multiples) . \\[ \\begin{align*} \\tau_{X^{(1), 90k}} &= (c_1, c_2) & \\text{}k\\text{ even}, \\\\ \\tau_{X^{(1), 90k}} &= (\\hat{c}_1, \\hat{c}_2) & \\text{}k\\text{ odd}, \\\\ \\end{align*} \\] Let’s go back diagram. base pattern, two level 1 units can expanded . code two level 1 units according corner values follows convinience: \\[ \\begin{align*} X_{<1>}^{(1)} \\quad \\text{}\\tau_{X^{(1)}} &= (1, 2), \\\\ X_{<2>}^{(1)} \\quad \\text{}\\tau_{X^{(1)}} &= (2, 1). \\\\ \\end{align*} \\] \\(<1>\\) \\(<2>\\) called expansion code base pattern \\(X\\).","code":""},{"path":"/articles/hilbert_curve.html","id":"connect-patterns","dir":"Articles","previous_headings":"Expand the curve","what":"Connect patterns","title":"Generalized Hilbert Curve","text":"two level 1 units \\(X^{(1)}\\) \\(Y^{(1)}\\) corners \\((c_1, c_2)\\) \\((c_3, c_4)\\) (course \\(c_2 = \\hat{c_1}\\), \\(c_4 = \\hat{c_3}\\)), construct sequence \\(XY\\), need ensure two units connectable. Since two units represented two square patterns can connected horizontally vertically, fit \\(c_2 = \\hat{c_3}\\), .e. forms \\(\\tau_{X^{(1)}} = (1, 2), \\tau_{y^{(1)}} = (1,2)\\) \\(\\tau_{X^{(1)}} = (2, 1), \\tau_{y^{(1)}} = (2,1)\\). easy see, can apply sequence length. short, corner values base patterns sequence . Next Let’s extend base patterns rotations. Denote two level 1 units \\(X^{(1),\\alpha} Y^{(1),\\beta}\\), first assign expansion code \\(\\) first unit, say \\(X_{<>}^{(1),\\alpha}\\) (\\(\\\\{1,2\\}\\)), define complement expansion code \\(j\\) : \\[ j = \\left\\{\\begin{matrix} 1 & \\text{}= 2,\\\\  2 & \\text{}= 1.\\\\  \\end{matrix}\\right. \\] expansion code \\(Y^{(1),\\beta}\\) determined \\(k = (\\beta - \\alpha)/90\\): \\[ \\left\\{\\begin{matrix} Y^{(1),\\beta}_{<>}, & \\text{}k\\text{ even}, \\\\ Y^{(1),\\beta}_{<j>}, & \\text{}k\\text{ odd}. \\\\ \\end{matrix}\\right. \\] means \\(\\beta-\\alpha\\) even multiples 90 degrees, \\(Y^{(1),\\beta}\\) expansion code \\(X^{(1),\\alpha}\\); \\(\\beta-\\alpha\\) odd multiples 90 degrees, \\(Y^{(1),\\beta}\\) complement code \\(X^{(1),\\alpha}\\). example, starting \\(^{90}\\), extend , choose \\(I_1^{90}\\) level 1 form \\[ P_1 = I_1^{90} = (RL^{90}LR^{270})^{90} = R^{90}L^{180}L^{90}R \\] extend level 2, assign expansion code \\(RLRL\\). start first pattern \\(R\\), two options, use \\(R_1\\) (write \\(R_{<1>}^{(1)}\\) \\(R_1\\) simplicity), according rules defined befoe, can assign expansion codes four base patterns: \\[ P_2 = R_1^{90}L_2^{180}L_1^{90}R_2 \\] extending level 0, can obtain final sequence base patterns level 2 curve: \\[ \\begin{align*} P_2 &= (IRR^{90}L^{180})^{90}(ILL^{270}R^{180})^{180}(RL^{90}LI^{270})^{90}(LR^{270}RI^{90}) \\\\     &= ^{90}R^{90}R^{180}L^{270}^{180}L^{180}L^{90}RR^{90}L^{180}L^{90}ILR^{270}RI^{90} \\\\ \\end{align*} \\] way, rotations second base pattern sequence can automatically calculated first base pattern. expanding curve level k-1 level k, level k-1, need pre-select transverse code first base pattern, transverse code remainingbase patterns level k-1 determined, ensures expanded \\(4^{k-1}\\) 2x2 units connected. Finally, sequence transverse code base unit expansion called transverse path. E.g. two different transverse paths \\(R_1\\) 2x2 unit, determined expansion code first base pattern:  two transverse paths can written : \\[ \\begin{align*} \\mathcal{p}_1 &= (1, 1, 2, 1) \\\\ \\mathcal{p}_2 &= (2, 2, 1, 2) \\\\ \\end{align*} \\]","code":"plot_transverse_paths(SFC_RULES_HILBERT, SFC_RULES_HILBERT@rules$R[[1]])"},{"path":"/articles/hilbert_curve.html","id":"encode-the-curve","dir":"Articles","previous_headings":"","what":"Encode the curve","title":"Generalized Hilbert Curve","text":"Let’s start single base pattern initial seed. explained, level expansion, expansion code selected first base pattern determine transverse path whole sequence. possible expansions single base pattern can described following diagram.  , level k, total number different forms 2x2 curve \\(2^k\\) level two transverse paths select. Taking \\(R\\) initial seed, size full set level-3 curves 8: Note orientation \\(R\\) bottom right .  , knowing intial seed expansion code (first base pattern) step, curve fully determined. can describe \\(2^k \\times 2^k\\) curve denoted \\(\\mathcal{C}_k\\) : \\[ \\mathcal{C}_k := X^{(0)}|\\pi_1 \\pi_2 ... \\pi_k \\quad \\pi_i \\\\{1, 2\\} \\] expansion code sequence, code left, corresponds top-level curve, code right sequence, corresponds bottom-level curve. Note sequence \\((\\pi_1 \\pi_2, ..., \\pi_k)\\) can represented sequence binary bits, sequence expansion code level can also described integer: \\[ X|111 = X|0_3 \\\\ X|121 = X|2_3 \\\\ X|222 = X|7_3 \\] specific base pattern can induce \\(2^k\\) different forms curves level \\(k\\), total number forms 9 base patterns 4 rotations \\[ 4 \\times 9 \\times 2^k = 36 \\times 2^k \\]","code":"draw_multiple_curves(     sfc_hilbert(\"R\", code = \"111\"),     sfc_hilbert(\"R\", code = \"112\"),     sfc_hilbert(\"R\", code = \"121\"),     sfc_hilbert(\"R\", code = \"122\"),     sfc_hilbert(\"R\", code = \"211\"),     sfc_hilbert(\"R\", code = \"212\"),     sfc_hilbert(\"R\", code = \"221\"),     sfc_hilbert(\"R\", code = \"222\"),     nrow = 2)"},{"path":"/articles/hilbert_curve.html","id":"specific-forms","dir":"Articles","previous_headings":"Encode the curve","what":"Specific forms","title":"Generalized Hilbert Curve","text":"Hilbert curve, Moore curve \\(\\beta-\\Omega\\) curve just special forms 2x2 curve. special expansion code sequences seed base patterns.  sequence type code levels: \\[ \\pi_1, \\pi_2, ..., \\pi_{k-1}, \\pi_{k} \\] particularlly, last two type codes construct unit 4x4 observable unit curve. define following shape basic units Hilbert curve, .e. Hilbert units:  can define “general Hilbert curve” \\(\\mathcal{H}_k\\) : \\[ \\mathcal{H}_k := X^{\\theta}|\\pi_1 \\pi_2 ... \\pi_{k_-1} \\pi_k \\quad X \\\\{, R, L, U\\}, \\pi_{k-1} = \\pi_k \\] can also define \\(\\beta\\) unit \\(\\Omega\\) unit following two:  genral “\\(\\beta-\\Omega\\) curve” \\(\\mathcal{B}_k\\) (k >= 3) defined : \\[ \\mathcal{B}_k := C^{\\theta}|\\pi_1 \\pi_2 ... \\pi_{k_-1}, \\pi_k \\quad \\pi_{k-1} \\ne \\pi_k \\] Last “general Moore curve” \\(\\mathcal{M}_k\\) defined : \\[ \\mathcal{M}_k := U^{\\theta}|\\pi_1 \\pi_2 ... \\pi_{k_-1}, \\pi_k \\quad \\pi_1 \\ne \\pi_2, \\pi_2 = \\pi_3 = ... = \\pi_k \\]","code":"p1 = sfc_hilbert(\"I\", code =  \"111\", rot = -90) p2 = sfc_hilbert(\"U\", code =  \"211\", rot = 180) p3 = sfc_hilbert(\"C\", code = \"2121\", rot = -90)  draw_multiple_curves(p1, p2, p3,   title = c(\"Hilbert\", \"Moore\", \"Beta-Omega\")) draw_multiple_curves(     sfc_hilbert(\"R\", \"11\"),      sfc_hilbert(\"R\", \"22\"),      extend = FALSE) draw_multiple_curves(     sfc_hilbert(\"L\", \"21\"),     sfc_hilbert(\"I\", \"12\", rot = -90) )"},{"path":"/articles/hilbert_curve.html","id":"combinations-of-the-expansion-codes","dir":"Articles","previous_headings":"Encode the curve","what":"Combinations of the expansion codes","title":"Generalized Hilbert Curve","text":"Let’s go back sequence curve level k \\[ \\mathcal{C}_k = X^{(0)}|\\pi_1 \\pi_2 ... \\pi_k \\] equation represents curve starting \\(X^{(0)}\\) expands k times. can merge \\(X^{(0)}\\) first expansion form new initial seed, expand curve k-1 times, written : \\[ \\begin{align*} \\mathcal{C}_k &= (X^{(0)}|\\pi_1) | \\pi_2 ... \\pi_k \\\\               &=  X^{(1)_{<\\pi_1>} | \\pi_2 ... \\pi_k \\end{align*} \\] Similarlly can move \\(\\pi_i\\) left side: \\[ \\mathcal{C}_k = (X^{(0)}|\\pi_1 ... \\pi_i) | \\pi_{(+1)} ... \\pi_k \\] move one \\(\\pi\\) per time expand new initial seed. \\[ \\mathcal{C}_k = {[(X^{(0)}|\\pi_1)| \\pi_2] | ...}| \\pi_k \\] Simply written : \\[ \\mathcal{C}_k = X^{(0)}|\\pi_1 | \\pi_2 | ... | \\pi_k \\] following example corresponds sequence \\(R|1212\\).  can merge group neighbouring expansions form new expansion rule, e.g. \\[ \\mathcal{C}_k = X^{(0)}| \\pi_1 \\pi_2 | \\pi_3 \\pi_4 | ... | \\pi_{k-1} \\pi_k \\] means, instead 2x2 expansion, now can 4x4 expansion, expansion mode determined \\(\\pi_{-1} \\pi_i\\). Let’s define new expansion \\(\\lambda\\) group two 2x2 expansions: \\[ \\begin{align*} \\lambda &= \\pi \\pi' \\\\ \\lambda &= \\left\\{\\begin{matrix} 1,& \\pi \\pi' = 1 1 \\\\ 2,& \\pi \\pi' = 1 2 \\\\ 3,& \\pi \\pi' = 2 1 \\\\ 4,& \\pi \\pi' = 2 2 \\\\ \\end{matrix}\\right. \\end{align*} \\] case, 4x4 expansion four expansion code 1/2/3/4. 4x4 expansion identical 2x2 expansion: \\[ X|\\lambda_1 \\lambda_2 ... = X|\\pi_1\\pi_1' \\pi_2 \\pi_2' ... \\] Next examples show level 0-3 4x4 expansions:","code":"initial = sfc_seed(\"R\") draw_multiple_curves(     sfc_hilbert(initial, \"1212\"),     sfc_hilbert(sfc_hilbert(initial, \"1\"), \"212\"),     sfc_hilbert(sfc_hilbert(initial, \"12\"), \"12\"),     sfc_hilbert(sfc_hilbert(initial, \"121\"), \"2\"),     sfc_hilbert(sfc_hilbert(initial, \"1212\"), NULL),     sfc_hilbert(sfc_hilbert(sfc_hilbert(sfc_hilbert(initial, \"1\"), \"2\"), \"1\"), \"2\"),     nrow = 1 ) initial = sfc_hilbert(\"R\") sfc_4x4 = function(initial, code) {     map = c(\"1\" = \"11\", \"2\" = \"12\", \"3\" = \"21\", \"4\" = \"22\")     code = strsplit(code, \"\")[[1]]     code2 = paste(map[code], collapse = \"\")     sfc_hilbert(initial, code2) } draw_multiple_curves(     initial, grob(), grob(), grob(),     sfc_4x4(initial, \"1\"),     sfc_4x4(initial, \"2\"),     sfc_4x4(initial, \"3\"),     sfc_4x4(initial, \"4\"),     sfc_4x4(initial, \"11\"),     sfc_4x4(initial, \"12\"),     sfc_4x4(initial, \"23\"),     sfc_4x4(initial, \"34\"),     nrow = 3 )"},{"path":"/articles/hilbert_curve.html","id":"seed-as-a-sequence","dir":"Articles","previous_headings":"","what":"Seed as a sequence","title":"Generalized Hilbert Curve","text":"demonstrated \\(X\\) single base pattern. Actually restriction length seed sequence. seed sequence determines global structure final curve. following example, global structure \\(^{90}RL\\), horizonal staring left, go straight, turn right turn left. can expand normal way.  spiral seed sequence:  Expand spiral 2x2 curves:  Note base patterns /L/R, constructing complex initial pattern sequence, \\(U\\) can used form \\((UU^{180})^\\theta\\), \\(C\\) self-closed connected base patterns, \\(B\\), \\(D\\), \\(P\\) \\(Q\\) half-closed can used start end pattern sequence. Note initiali squence can consturcted “straight”, “lef” “right”. Crossing allowed.","code":"p = sfc_hilbert(\"IRL\", code = c(1, 1, 1, 1), rot = 90) plot(p) p = sfc_seed(\"LLLILILIILIILIIILIIILIIII\", universe = sfc_universe(SFC_RULES_HILBERT)) plot(p, grid = TRUE) p2 = sfc_hilbert(p, code = c(1, 1, 1, 1)) plot(p2) p = sfc_hilbert(\"IIIIIIIIII\", code = \"11111\", rot = 90) plot(p)"},{"path":"/articles/hilbert_curve.html","id":"partial-curve","dir":"Articles","previous_headings":"","what":"Partial curve","title":"Generalized Hilbert Curve","text":"curve essentially sequence can subsetted:","code":"p = sfc_hilbert(\"R\", \"11111\") length(p) ## [1] 1024 plot(p[200:400]) p[200:400] ## A sequence of 201 base patterns. ##   R(270)R(180)L(90)L(180)  I(270)L(270)R(0)R(270) ##   I(180)R(180)L(90)L(180)  R(270)I(180)R(180)R(90) ##   .... other 22 lines .... ##   R(90)R(0)L(270)L(0)      I(90)L(90)R(180)R(90) ##   I(0) p[200:400, FALSE] ## A sequence of 201 base patterns. ##   R(270)R(180)L(90)L(180)  I(270)L(270)R(0)R(270) ##   I(180)R(180)L(90)L(180)  R(270)I(180)R(180)R(90) ##   .... other 22 lines .... ##   R(90)R(0)L(270)L(0)      I(90)L(90)R(180)R(90) ##   I(0)"},{"path":"/articles/hilbert_curve.html","id":"flip-and-reverse","dir":"Articles","previous_headings":"","what":"Flip and reverse","title":"Generalized Hilbert Curve","text":"design diagram let forms curve can expanded rotation, .e. without leaving plate (flipping) modify sequence (reverse). However, can define flipping horizontal, vertical diagonal. Flippping base pattern can easily obtained, focused sequence patterns. Observing diagram, expandiong step, three base pattersn \\(\\), \\(L\\) \\(R\\) used. Thus following, restructed notation \\(X\\) set \\(\\{, L, R\\}\\).","code":""},{"path":"/articles/hilbert_curve.html","id":"horizontal-flip","dir":"Articles","previous_headings":"Flip and reverse","what":"Horizontal flip","title":"Generalized Hilbert Curve","text":"first calculate horizontal flipping single base pattern: \\[  \\begin{align*} \\mathrm{Flip}_\\mathrm{h}(^\\alpha) &= ^\\alpha, & \\alpha \\\\{0, 180\\}, \\\\ \\mathrm{Flip}_\\mathrm{h}(^\\beta) &= ^{\\beta + 180}, & \\beta \\\\{90, 270\\}, \\\\ \\mathrm{Flip}_\\mathrm{h}(R^\\alpha) &= L^\\alpha, & \\alpha \\\\{0, 180\\}, \\\\ \\mathrm{Flip}_\\mathrm{h}(R^\\beta) &= L^{\\beta + 180}, & \\beta \\\\{90, 270\\}, \\\\ \\mathrm{Flip}_\\mathrm{h}(L^\\alpha) &= R^\\alpha, & \\alpha \\\\{0, 180\\}, \\\\ \\mathrm{Flip}_\\mathrm{h}(L^\\beta) &= R^{\\beta + 180}, & \\beta \\\\{90, 270\\}. \\\\ \\end{align*} \\] flipping sequence base patterns sequencing individual flipping base patterns: \\[ \\mathrm{Flip}_\\mathrm{h}(X_1 X_2 ...) = \\mathrm{Flip}_\\mathrm{h}(X_1)\\mathrm{Flip}_\\mathrm{h}(X_2)... \\]","code":"draw_multiple_curves(     p, sfc_hflip(p),      nrow = 1)"},{"path":"/articles/hilbert_curve.html","id":"vertical-flip","dir":"Articles","previous_headings":"Flip and reverse","what":"Vertical flip","title":"Generalized Hilbert Curve","text":"Vertical flipping can constructed similar way horizontal flipping, can simply constructed first rotating pattern \\(180^\\circ\\) horizontal flipping: \\[ \\begin{align*} \\mathrm{Flip}_\\mathrm{v}(X^\\theta) &= \\mathrm{Flip}_\\mathrm{h}((X^\\theta)^{180}) \\\\      &= \\mathrm{Flip}_\\mathrm{h}(X^{\\theta+180}) \\end{align*} \\] Rotation horizontal flip can swtiched: \\[ \\begin{align*} \\mathrm{Flip}_\\mathrm{v}(X^\\theta) &= (\\mathrm{Flip}_\\mathrm{h}(X^\\theta))^{180} \\end{align*} \\]  easy seee \\[ \\begin{align*} \\mathrm{Flip}_\\mathrm{h}(\\mathrm{Flip}_\\mathrm{h}(X)) &= \\mathrm{Flip}_\\mathrm{v}(\\mathrm{Flip}_\\mathrm{v}(X)) = X \\\\ \\mathrm{Flip}_\\mathrm{v}(\\mathrm{Flip}_\\mathrm{h}(X)) &= \\mathrm{Flip}_\\mathrm{h}(\\mathrm{Flip}_\\mathrm{v}(X)) = X^{180} \\end{align*} \\]   Vertical flipping can also expanded individual base patterns: \\[ \\mathrm{Flip}_\\mathrm{v}(X_1 X_2 ...) = \\mathrm{Flip}_\\mathrm{v}(X_1)\\mathrm{Flip}_\\mathrm{v}(X_2)... \\]","code":"draw_multiple_curves(     p, sfc_vflip(p), sfc_rotate(p, 180), sfc_rotate(sfc_hflip(p), 180),      nrow = 1) draw_multiple_curves(     p, sfc_hflip(sfc_hflip(p)), sfc_vflip(sfc_vflip(p)),      nrow = 1) draw_multiple_curves(     sfc_rotate(p, 180), sfc_vflip(sfc_hflip(p)), sfc_hflip(sfc_vflip(p)),      nrow = 1)"},{"path":"/articles/hilbert_curve.html","id":"diagonal-flipping","dir":"Articles","previous_headings":"Flip and reverse","what":"Diagonal flipping","title":"Generalized Hilbert Curve","text":"two types diagonal flippig: diagonal slop 1 (bottomleft - topright) -1 (topleft - bottomright). \\[ \\begin{align*} \\mathrm{Flip}_\\mathrm{d}^1(X^\\theta) &= \\mathrm{Flip}_\\mathrm{h}(X^{\\theta - 90}) = \\mathrm{Flip}_\\mathrm{v}(X^{\\theta + 90}) \\\\ \\mathrm{Flip}_\\mathrm{d}^{-1}(X^\\theta) &= \\mathrm{Flip}_\\mathrm{h}(X^{\\theta + 90}) = \\mathrm{Flip}_\\mathrm{v}(X^{\\theta - 90}) \\end{align*} \\]   Also \\[ \\mathrm{Flip}_\\mathrm{d}^1(\\mathrm{Flip}_\\mathrm{d}^{1}(X)) = \\mathrm{Flip}_\\mathrm{d}^{-1}(\\mathrm{Flip}_\\mathrm{d}^{-1}(X)) = X \\]  \\[ \\mathrm{Flip}_\\mathrm{d}^{-1}(\\mathrm{Flip}_\\mathrm{d}^{1}(X)) = \\mathrm{Flip}_\\mathrm{d}^{1}(\\mathrm{Flip}_\\mathrm{d}^{-1}(X)) = X^{180} \\]  Diagonal flipping can also expanded individual base patterns: \\[ \\mathrm{Flip}_\\mathrm{d}(X_1 X_2 ...) = \\mathrm{Flip}_\\mathrm{d}(X_1)\\mathrm{Flip}_\\mathrm{d}(X_2)... \\]","code":"draw_multiple_curves(     p,      sfc_dflip(p, 1),      sfc_hflip(sfc_rotate(p, -90)),      sfc_vflip(sfc_rotate(p, 90)),     nrow = 1 ) draw_multiple_curves(     p,      sfc_dflip(p, -1),      sfc_hflip(sfc_rotate(p, 90)),      sfc_vflip(sfc_rotate(p, -90)),     nrow = 1 ) draw_multiple_curves(     p,      sfc_dflip(sfc_dflip(p, 1), 1),      sfc_dflip(sfc_dflip(p, -1), -1) ) draw_multiple_curves(     sfc_rotate(p, 180),      sfc_dflip(sfc_dflip(p, 1), -1),      sfc_dflip(sfc_dflip(p, -1), 1) )"},{"path":"/articles/hilbert_curve.html","id":"reverse","dir":"Articles","previous_headings":"Flip and reverse","what":"Reverse","title":"Generalized Hilbert Curve","text":"Globally, complete sequence reversed, also individual patterns also adjusted. \\[ \\mathrm{Rev}(X_1 X_2 ... X_n) = (X'_n ... X'_2 X'_1) \\] \\[ X'_i = \\left\\{\\begin{matrix} ^{\\theta_i + 180} & \\text{} X_i = ^{\\theta_i},\\\\  L^{\\theta_i - 90} & \\text{} X_i = R^{\\theta_i},\\\\  R^{\\theta_i + 90} & \\text{} X_i = L^{\\theta_i}.\\\\  \\end{matrix}\\right. \\\\{1, ..., n\\} \\] flipping reverse also supported, patterns level = 1 can represented , e.g. \\[ \\begin{align*} ^{(1)}_2 &= \\mathrm{Flip}_\\mathrm{h}(^{(1)}_1) \\\\ L^{(1)}_2 &= \\mathrm{Flip}_\\mathrm{h}(R^{(1)}_1) \\\\ L^{(1)}_1 &= \\mathrm{Rev}((R^{(1)}_1)^{90}) \\\\ R^{(1)}_2 &= \\mathrm{Rev}(\\mathrm{Flip}_\\mathrm{d}^{-1}(R^{(1)}_1)) \\end{align*} \\] can see, flippping reversing increase complexity interpretation, thus considered flip xxx allows rotation expanding curve.","code":""},{"path":"/articles/hilbert_curve.html","id":"local-flipping","dir":"Articles","previous_headings":"Flip and reverse","what":"Local flipping","title":"Generalized Hilbert Curve","text":"introduced flipping whole sequence. another type flipping like local flipping flips subunits curve -direction -direction subunits changed. Compare following examples. sfc_meander() sfc_peano() makes Meander Peano 3x3 curves introduced vignettes.","code":"p = sfc_meander(\"R\", 2, rot = -90) draw_multiple_curves(     p,      sfc_hflip(p),      sfc_hflip(p, fix_ends = TRUE),      nrow = 1) p = sfc_meander(\"L\", 2, rot = -90) draw_multiple_curves(     p,      sfc_vflip(p),      sfc_vflip(p, fix_ends = TRUE),      nrow = 1) p = sfc_peano(\"I\", 2) draw_multiple_curves(     p,      sfc_dflip(p, 1),      sfc_dflip(p, 1, fix_ends = TRUE),      nrow = 1)"},{"path":"/articles/hilbert_curve.html","id":"visualize-curves-in-other-layouts","dir":"Articles","previous_headings":"","what":"Visualize curves in other layouts","title":"Generalized Hilbert Curve","text":"can make e.g. circular transformation original coordinates:  spiral layout:","code":"p = sfc_hilbert(\"IIIIIIIIII\", \"11111\", rot = 90) loc = sfc_segments(p) n = nrow(loc) library(circlize) circos.par(gap.degree = 0, cell.padding = c(0, 0)) circos.initialize(sectors = \"foo\", xlim = range(loc[, 1])) col_fun = colorRamp2(seq(1, n, length = 11), RColorBrewer::brewer.pal(11, \"Spectral\")) circos.track(ylim = range(loc[, 2]), panel.fun = function(x, y) {     circos.segments(loc[1:(n-1), 1], loc[1:(n-1), 2], loc[2:n, 1], loc[2:n, 2], col = col_fun(1:(n-1)), lwd = 2) }, track.height = 0.5, bg.border = NA) circos.clear() p = sfc_hilbert(strrep(\"I\", 30), \"11111\", rot = 90) loc = sfc_segments(p) n = nrow(loc) col_fun = colorRamp2(seq(1, n, length = 11), RColorBrewer::brewer.pal(11, \"Spectral\"))  library(spiralize)  spiral_initialize(xlim = range(loc[, 1]), start = 360, end = 360*3) spiral_track(ylim = range(loc[, 2]), height = 0.95, background = FALSE) spiral_segments(loc[1:(n-1), 1], loc[1:(n-1), 2], loc[2:n, 1], loc[2:n, 2], gp = gpar(col = col_fun(1:(n-1)), lwd = 1))"},{"path":"/articles/meander_curve.html","id":"base-patterns","dir":"Articles","previous_headings":"","what":"Base patterns","title":"Generalized Meander Curve","text":"Meander curve different set base units.  expansions similar Hilbert curve, also flipped version units can flipped horizontally vertically various levels.  level expansion, two transverse paths:","code":"draw_rules_meander() draw_rules_meander(flip = TRUE) plot_transverse_paths(SFC_RULES_MEANDER, SFC_RULES_MEANDER@rules$I[[1]])"},{"path":"/articles/meander_curve.html","id":"curves","dir":"Articles","previous_headings":"","what":"Curves","title":"Generalized Meander Curve","text":"possible forms Meander curve level 3 taking R(0) seed:  curves level 3 taking nine base patterns respectively:","code":"draw_multiple_curves(     sfc_meander(\"R\", code = \"111\"),     sfc_meander(\"R\", code = \"112\"),     sfc_meander(\"R\", code = \"121\"),     sfc_meander(\"R\", code = \"122\"),     sfc_meander(\"R\", code = \"211\"),     sfc_meander(\"R\", code = \"212\"),     sfc_meander(\"R\", code = \"221\"),     sfc_meander(\"R\", code = \"222\"),     nrow = 2, lwd = 2) draw_multiple_curves(     sfc_meander(\"I\", code = \"111\"),     sfc_meander(\"R\", code = \"111\"),     sfc_meander(\"L\", code = \"111\"),     sfc_meander(\"U\", code = \"111\"),     sfc_meander(\"B\", code = \"111\"),     sfc_meander(\"D\", code = \"111\"),     sfc_meander(\"P\", code = \"111\"),     sfc_meander(\"Q\", code = \"111\"),     sfc_meander(\"C\", code = \"111\"),     nrow = 3, lwd = 2)"},{"path":"/articles/meander_curve.html","id":"unit-flipping","dir":"Articles","previous_headings":"","what":"Unit flipping","title":"Generalized Meander Curve","text":"Flipping (horizotal vertical) can applied specifying index hierarchical unit curve.","code":"p = sfc_meander(\"I\", 11) draw_multiple_curves(     p,     sfc_flip_unit(p, \"1\"),  # bottom left     sfc_flip_unit(p, \"2\"),  # bottom middle     sfc_flip_unit(p, c(\"6\", \"7\", \"8\", \"9\")), # top left, four units     nrow = 2 )"},{"path":"/articles/meander_curve.html","id":"number-of-different-forms","dir":"Articles","previous_headings":"","what":"Number of different forms","title":"Generalized Meander Curve","text":"total number different forms Meander curve level \\(k\\) composed two parts: \\(9 \\cdot 4 \\cdot 2^k\\) number applying expanding rules, \\(2^{\\frac{9^k - 1}{8}}\\) number units levels unit can flipped independently. \\[ 9 \\cdot 4 \\cdot 2^k \\cdot 2^{\\frac{9^k - 1}{8}} \\]","code":""},{"path":"/articles/meander_curve.html","id":"seed-as-a-sequence","dir":"Articles","previous_headings":"","what":"Seed as a sequence","title":"Generalized Meander Curve","text":"","code":"seed = sfc_sequence(\"IILILILI\", rot = -90, universe = sfc_universe(SFC_RULES_MEANDER)) plot(seed, grid = TRUE) sfc_meander(seed, code = \"111\") |> plot(lwd = 2)"},{"path":"/articles/nxn_curve.html","id":"x4-peano-curve","dir":"Articles","previous_headings":"","what":"4x4 Peano curve","title":"nxn-Curve","text":"create rules expansion level-0 level-1 4x4 Peano unit. cover three major base patterns /R/L. creating expansion rules, notice following two requirements: -direction -direction level-1 unit level-0 base patterns. two level-1 units corner values “12/21”, “12” always first one. base pattern, two types level-1 units. \\(I_1\\) : \\(I_2\\) basically horizontal flip \\(I_1\\): define \\(R_1\\), first rotate \\(I_2\\) -90 degrees, change first base pattern \\(^{0}\\). \\(R_2\\) based \\(I_2\\) change last base pattern \\(^{-90}\\) \\(L_1\\) horizontal flip \\(R_2\\) \\(L_2\\) horizontal flip \\(R_1\\). Let’s validate whether level-1 units correct forms orientations:  Next generate sfc_rules object sfc_rules() function. rules SFC_RULES_4x4_PEANO, use generator function sfc_generator() generate two functions: sfc_4x4_peano(): main function generating curves. draw_rules_4x4_peano(): draw expansions level-0 level-1. \"4x4_peano\" suffix two function names.","code":"UNIVERSE_4x4_PEANO = c(\"I\", \"R\", \"L\") RULES_4x4_PEANO = list() RULES_4x4_PEANO[[\"I\"]][[1]] = sfc_unit(\"RIILLIIRRIILLIIR\", rot = 0, universe = UNIVERSE_4x4_PEANO) RULES_4x4_PEANO[[\"I\"]][[2]] = sfc_hflip(RULES_4x4_PEANO[[\"I\"]][[1]]) u = sfc_rotate(RULES_4x4_PEANO[[\"I\"]][[2]], -90) u[1] = sfc_sequence(\"I\", rot = 0) RULES_4x4_PEANO[[\"R\"]][[1]] = u u = RULES_4x4_PEANO[[\"I\"]][[2]] u[length(u)] = sfc_sequence(\"I\", rot = -90) RULES_4x4_PEANO[[\"R\"]][[2]] = u RULES_4x4_PEANO[[\"L\"]][[1]] = sfc_hflip(RULES_4x4_PEANO[[\"R\"]][[2]]) RULES_4x4_PEANO[[\"L\"]][[2]] = sfc_hflip(RULES_4x4_PEANO[[\"R\"]][[1]]) draw_multiple_curves(     RULES_4x4_PEANO[[\"I\"]][[1]],     RULES_4x4_PEANO[[\"I\"]][[2]],     RULES_4x4_PEANO[[\"R\"]][[1]],     RULES_4x4_PEANO[[\"R\"]][[2]],     RULES_4x4_PEANO[[\"L\"]][[1]],     RULES_4x4_PEANO[[\"L\"]][[2]],     nrow = 2, extend = TRUE ) SFC_RULES_4x4_PEANO = sfc_rules(rules = RULES_4x4_PEANO,         name = \"Peano 4x4\",         bases = BASE_LIST[UNIVERSE_4x4_PEANO]) SFC_RULES_4x4_PEANO ## Name: Peano 4x4 ## I | I_1 = R(0)I(270)I(270)L(270)L(0)I(90)I(90)R(90)R(0)I(270)I(270)L(270)L(0)I(90)I(90)R(90)  corner = (1, 2)  ##     I_2 = L(0)I(90)I(90)R(90)R(0)I(270)I(270)L(270)L(0)I(90)I(90)R(90)R(0)I(270)I(270)L(270)  corner = (2, 1)  ## R | R_1 = I(0)I(0)I(0)R(0)R(270)I(180)I(180)L(180)L(270)I(0)I(0)R(0)R(270)I(180)I(180)L(180)  corner = (1, 2)  ##     R_2 = L(0)I(90)I(90)R(90)R(0)I(270)I(270)L(270)L(0)I(90)I(90)R(90)R(0)I(270)I(270)I(270)  corner = (2, 1)  ## L | L_1 = R(0)I(270)I(270)L(270)L(0)I(90)I(90)R(90)R(0)I(270)I(270)L(270)L(0)I(90)I(90)I(90)  corner = (1, 2)  ##     L_2 = I(0)I(0)I(0)L(0)L(90)I(180)I(180)R(180)R(90)I(0)I(0)L(0)L(90)I(180)I(180)R(180)     corner = (2, 1) sfc_generator(SFC_RULES_4x4_PEANO, \"4x4_peano\") ## The following two functions are exported to the current top environment: ##   - sfc_4x4_peano() ##   - draw_rules_4x4_peano() draw_rules_4x4_peano() draw_multiple_curves(     sfc_4x4_peano(\"I\", \"111\"),     sfc_4x4_peano(\"I\", \"121\"),     lwd = 2, nrow = 1 )"},{"path":"/articles/nxn_curve.html","id":"x5-meander-curve","dir":"Articles","previous_headings":"","what":"5x5 Meander curve","title":"nxn-Curve","text":"Similarly, can generate expansion rules 5x5 Meander curve following unit:  curve generator: simplicity, currently flipped expansion rules supported sfc_generator().","code":"UNIVERSE_5x5_MEANDER = c(\"I\", \"R\", \"L\") RULES_5x5_MEANDER = list() RULES_5x5_MEANDER[[\"I\"]][[1]] = sfc_unit(\"IIIRIIRIRRLLILIILIIILIIIR\", rot = 0, universe = UNIVERSE_5x5_MEANDER) RULES_5x5_MEANDER[[\"I\"]][[2]] = sfc_hflip(RULES_5x5_MEANDER[[\"I\"]][[1]])  u = sfc_rotate(RULES_5x5_MEANDER[[\"I\"]][[2]], -90) u[1] = sfc_sequence(\"R\", rot = 0) RULES_5x5_MEANDER[[\"R\"]][[1]] = u u = RULES_5x5_MEANDER[[\"I\"]][[2]] u[length(u)] = sfc_sequence(\"I\", rot = -90) RULES_5x5_MEANDER[[\"R\"]][[2]] = u  RULES_5x5_MEANDER[[\"L\"]][[1]] = sfc_hflip(RULES_5x5_MEANDER[[\"R\"]][[2]]) RULES_5x5_MEANDER[[\"L\"]][[2]] = sfc_hflip(RULES_5x5_MEANDER[[\"R\"]][[1]])  SFC_RULES_5x5_MEANDER = sfc_rules(rules = RULES_5x5_MEANDER,         name = \"Meander 5x5\",         bases = BASE_LIST[UNIVERSE_5x5_MEANDER]) sfc_generator(SFC_RULES_5x5_MEANDER, \"5x5_meander\") ## The following two functions are exported to the current top environment: ##   - sfc_5x5_meander() ##   - draw_rules_5x5_meander() draw_rules_5x5_meander() draw_multiple_curves(     sfc_5x5_meander(\"I\", 11),     sfc_5x5_meander(\"I\", 21),     lwd = 2, nrow = 1 )"},{"path":"/articles/nxn_curve.html","id":"unit-with-1122-corners","dir":"Articles","previous_headings":"","what":"Unit with 11/22 corners","title":"nxn-Curve","text":"next demonstrate 5x5 curve based 11/22 unit.  Similar SFC_RULES_PEANO, include base pattern J. example, \\(J\\) basically letter switch \\(\\) (.e. <-> J, R <-> L). \\(R\\) based \\(\\) last letter changed R \\(L\\) based \\(J\\) last letter changed L. Sometimes may need several edits sequences base units make /J/R/L correct forms. Directly plotting helps validate units:  may also validate whether transverse path exist, e.g. \\(\\):  everything works fine, can generate curve functions:   can manually flip level-1 units make every two neighbour units symmetric (can also use sfc_apply()):  Please note curves based 11/22 units, following structure (rotated form)  minimal length two vertical segment even number, segment allow even numbers units put .","code":"UNIVERSE_5x5_FOO = c(\"I\", \"J\", \"R\", \"L\") RULES_5x5_FOO = list() RULES_5x5_FOO[[\"I\"]][[1]] = sfc_unit(\"IJRRILJILLJRILJRRIJRILLJI\", rot = 0, universe = UNIVERSE_5x5_FOO) RULES_5x5_FOO[[\"J\"]][[1]] = sfc_unit(\"JILLJRIJRRILJRILLJILJRRIJ\", rot = 0, universe = UNIVERSE_5x5_FOO) RULES_5x5_FOO[[\"R\"]][[1]] = sfc_unit(\"IJRRILJILLJRILJRRIJRILLJR\", rot = 0, universe = UNIVERSE_5x5_FOO) RULES_5x5_FOO[[\"L\"]][[1]] = sfc_unit(\"JILLJRIJRRILJRILLJILJRRIL\", rot = 0, universe = UNIVERSE_5x5_FOO)  SFC_RULES_5x5_FOO = sfc_rules(rules = RULES_5x5_FOO,         name = \"Foo 5x5\",         bases = BASE_LIST[UNIVERSE_5x5_FOO]) draw_multiple_curves(     RULES_5x5_FOO[[\"I\"]][[1]],     RULES_5x5_FOO[[\"J\"]][[1]],     RULES_5x5_FOO[[\"R\"]][[1]],     RULES_5x5_FOO[[\"L\"]][[1]],     nrow = 2, extend = TRUE ) plot_transverse_paths(SFC_RULES_5x5_FOO, RULES_5x5_FOO[[\"I\"]][[1]]) sfc_generator(SFC_RULES_5x5_FOO, \"5x5_foo\") ## The following two functions are exported to the current top environment: ##   - sfc_5x5_foo() ##   - draw_rules_5x5_foo() draw_rules_5x5_foo() p = sfc_5x5_foo(\"I\", 11) plot(p) sfc_flip_unit(p, c(\"4\", \"7\", \"8\", \"9\", \"11\", \"12\", \"15\", \"16\", \"18\", \"19\", \"20\", \"23\")) |> plot()"},{"path":"/articles/peano_curve.html","id":"base-patterns","dir":"Articles","previous_headings":"","what":"Base patterns","title":"Generalized Peano Curve","text":"following expansion rules level 0 level 1 Peanno curve. Note level 1 units vertical.  J level-0 (.e. going forward), correspond different patterns level-1 allow pattern rotate, flip. Also separating J makes one extension level-0 level-1 base pattern. Unlike Hilbert curve one transverse path, one transverse path level k.  makes expansion code level Peano curve always 1. Peano curve, can simpliy specify number level.  applying expansion rules, Peano curve fixed level \\(k\\). However, note level-1 level-\\(k\\) (\\(k \\ge 1\\)) pattern can flipped diagonal line without affecting structure parts curve. can flipped version original expansion rules level-1 units horizontal:  , example, expanding \\(^{(0)}\\) \\(^{(1)} = RI^{(270)}L^{(270)}LJ^{(90)}R^{(90)}RI^{(270)}L^{(270)}\\), base pattern can take flipped version independently, also \\(^{(1)}\\) whole can independently flipped.","code":"draw_rules_peano() plot_transverse_paths(SFC_RULES_PEANO, SFC_RULES_PEANO@rules$I[[1]]) p = sfc_peano(\"I\", level = 3) # the same as sfc_peano(\"I\", code = \"111\"), but 1 is only allowed plot(p) draw_rules_peano(flip = TRUE)"},{"path":"/articles/peano_curve.html","id":"number-of-different-forms","dir":"Articles","previous_headings":"","what":"Number of different forms","title":"Generalized Peano Curve","text":"level 0 level 1, two different forms: normal one flipped one: \\[ n_1 = 2 \\] level 1 level 2, nine points can expanded choosing normal base pattern flipped one. global unit level 2 can also normal form flipped form. \\[ n_2 = n_1^9 \\cdot 2 \\] can sequentially: \\[ \\begin{align*} n_3 &= n_2^9 \\cdot 2 \\\\     & ... \\\\ n_k &= n_{k-1}^9 \\cdot 2 \\\\ \\end{align*} \\] \\(n_k\\) can calculated : \\[ n_k = 2^{9^{k-1} + ... + 9 + 1} = 2^{\\frac{9^k - 1}{8}} \\] can calculate another way counting total number square units various levels Peano curve. curve level \\(k\\), number square unit level \\(\\) \\(9^{k-}\\). sum numbers level \\(k\\) level 1: \\[ \\sum_{=1}^{k} 9^{k-} = \\frac{9^k - 1}{8} \\] unit various levels can flipped independently. final number different forms Peano curve level \\(k\\) : \\[ n_k = 2^{\\frac{9^k - 1}{8}} \\] combining four base patterns four rotations, final number different forms Peano curve \\[ 4 \\cdot 4 \\cdot 2^{\\frac{9^k - 1}{8}} \\] Although number huge, vignette “Standard curves” can still define family Peano curves repeat certain flipping patterns recursively.","code":""},{"path":"/articles/peano_curve.html","id":"unit-flipping","dir":"Articles","previous_headings":"","what":"Unit flipping","title":"Generalized Peano Curve","text":"can set global flipping rule every level expansion.  Every unit can manually flipped specifying “hierarchy index”. Splitting curve 9 blocks recursively, index “93”, means 9th block first level hierarchy, within block, 3rd child-block. Notice orientation top-left corner top-right block right plot.  index can also specified vector, flipped applied sequentially (three units left curve).","code":"sfc_peano(\"I\", level = 3,      flip = c(FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)) |> plot() draw_multiple_curves(     p,     sfc_flip_unit(p, \"9:3\"),     nrow = 1 ) draw_multiple_curves(     p,     sfc_flip_unit(p, c(\"1\", \"2\", \"3\")),     nrow = 1 )"},{"path":"/articles/peano_curve.html","id":"the-standard-peano-curve","dir":"Articles","previous_headings":"","what":"The standard Peano curve","title":"Generalized Peano Curve","text":"previous section, demonstrate setting flip argument logical vector actually less useful. section, demonstrate set flip self-defined function support flexible adjustment Peano curves. several ways generate standard Peano curve level-1 (9x9) units oriented vertically. design “primary expansion rules” let level-1 units vertical, generate standard Peano curve, base letter curve rotation 90 270 degrees, replace flipped version. self-defined function flip() accepts one argument current curve expansion. adjusting standard Peano curve can easily done :  can mandatorily change level-1 units vertical. sfc_apply() applies self-defined function fun every units certain level (following example, applied level sfc_level(p)-1). self-defined function accepts one argument x current unit.  Directly use helper function change_level1_unit_orientation().  first method generates exact Peano curve every level vertical structure kept, next two methods, vertical pattern applied level-1 higher level can type structures.  horizontal case:  first method generates exact Peano curve every level vertical structure kept, next two methods, vertical pattern applied level-1 higher level can type structures. Unit flipping powerful way adjusting curves. get deeper explorations vignette “Unit flipping”.","code":"sfc_peano(\"I\", level = 4, flip = function(p) {     p@rot %in% c(90, 270) }) |> plot(lwd = 1) p = sfc_peano(\"I\", level = 4) sfc_apply(p, sfc_level(p)-1, function(u) {     if(level1_unit_orientation(u) == \"horizontal\") {         sfc_flip_unit(u)     } else {         u     } }) |> plot(lwd = 1) change_level1_unit_orientation(p, to = \"vertical\") |> plot(lwd = 1) p = sfc_peano(\"I\", rot = 90, level = 4) change_level1_unit_orientation(p, to = \"vertical\") |> plot(lwd = 1) p = sfc_peano(\"I\", rot = 90, level = 4) change_level1_unit_orientation(p, to = \"horizontal\") |> plot(lwd = 1)"},{"path":"/articles/peano_curve.html","id":"seed-as-a-sequence","dir":"Articles","previous_headings":"","what":"Seed as a sequence","title":"Generalized Peano Curve","text":"Beside using single base letter seed, sequence can used seed well.","code":"seed = sfc_sequence(\"IJILJILJILJI\", rot = -90, universe = sfc_universe(SFC_RULES_PEANO)) plot(seed, grid = TRUE) sfc_peano(seed, level = 3) |> plot(lwd = 2)"},{"path":[]},{"path":"/articles/standard_curves.html","id":"hilbert-curve-and-moore-curve","dir":"Articles","previous_headings":"2x2 standard curves","what":"Hilbert curve and Moore curve","title":"Standard curves","text":"standard Hilbert curve Moore curve use “Hilbert level-2 unit”:  global level, Hilbert curve uses “Hilbert structure” (left) Moore curve uses “Moore structure” (right):  Let’s check standard Hilbert curve various levels structures. Note Moore curve still uses Hilbert structure lower levels.   comparison, general Hilbert curves may “Hilbert structure” higher levels:  functions hilbert_curve() moore_curve() generated general function sfc_hilbert() choosing specific base patterns transverse path. example, standard Hilbert curve level 5 : standard Moore curve level 5 (first digits 2):","code":"p = hilbert_curve(level = 5) draw_multiple_curves(     p |> sfc_grob() |> add_base_structure(level = 2),     p |> sfc_grob() |> add_base_structure(level = 3),     p |> sfc_grob() |> add_base_structure(level = 4),     sfc_reduce(p, 4) |> sfc_grob() |> add_base_structure(level = 2),     sfc_reduce(p, 4) |> sfc_grob() |> add_base_structure(level = 3),     grob(),  # a null grob, a place holder     sfc_reduce(p, 3) |> sfc_grob() |> add_base_structure(level = 2),     sfc_reduce(p, 2),     ncol = 3, padding = unit(4, \"pt\")) p = moore_curve(level = 5) draw_multiple_curves(     p |> sfc_grob() |> add_base_structure(level = 2),     p |> sfc_grob() |> add_base_structure(level = 3),     p |> sfc_grob() |> add_base_structure(level = 4),     sfc_reduce(p, 4) |> sfc_grob() |> add_base_structure(level = 2),     sfc_reduce(p, 4) |> sfc_grob() |> add_base_structure(level = 3),     grob(),  # a null grob, a place holder     sfc_reduce(p, 3) |> sfc_grob() |> add_base_structure(level = 2),     sfc_reduce(p, 2),     ncol = 3, padding = unit(4, \"pt\")) p = sfc_hilbert(\"I\", \"21211\") draw_multiple_curves(     p |> sfc_grob() |> add_base_structure(level = 2),     p |> sfc_grob() |> add_base_structure(level = 3),     p |> sfc_grob() |> add_base_structure(level = 4),     nrow = 1, padding = unit(4, \"pt\")) sfc_hilbert(\"R\", code = \"11111\") sfc_hilbert(\"C\", code = \"21111\", rot = 90)"},{"path":"/articles/standard_curves.html","id":"beta-omega-curve","dir":"Articles","previous_headings":"2x2 standard curves","what":"Beta-Omega curve","title":"Standard curves","text":"\\(\\beta\\Omega\\)-curve (Michael Bader. Space-Filling Curves: Introduction Applications Scientific Computing, 2012 Springer, Figure 7.7) uses \\(\\beta\\) (left) \\(\\Omega\\) (right) units.  uses “Moore global structure”:  function beta_omega_curve() also generated sfc_hilbert(). E.g., \\(\\beta\\Omega\\)-curve level 5 actually (digits 1 2 turn):","code":"p = beta_omega_curve(level = 5) draw_multiple_curves(     p |> sfc_grob() |> add_base_structure(level = 2),     p |> sfc_grob() |> add_base_structure(level = 3),     p |> sfc_grob() |> add_base_structure(level = 4),     sfc_reduce(p, 4) |> sfc_grob() |> add_base_structure(level = 2),     sfc_reduce(p, 4) |> sfc_grob() |> add_base_structure(level = 3),     grob(),  # a null grob, a place holder     sfc_reduce(p, 3) |> sfc_grob() |> add_base_structure(level = 2),     sfc_reduce(p, 2),     ncol = 3, padding = unit(4, \"pt\")) sfc_hilbert(\"C\", \"12121\", rot = -90)"},{"path":[]},{"path":"/articles/standard_curves.html","id":"peano-curve","dir":"Articles","previous_headings":"3x3 standard curves","what":"Peano curve","title":"Standard curves","text":"basic unit Peano curve two different forms: vertical (left) horizontal (right) (course flipped versions):  standard Peano curve requires units various levels vertical.  general Peano curve huge number different forms flipping units various level. can still generate Peano curve specific patterns low levels (e.g. level-1). peano_curve() argument pattern defines patterns level-1. Since unit can flipped either vertically horizontally, value pattern string \"v\" \"h\" controls level-1 units selected compose level-2. maximal number letters pattern exeed 9. shorter 9, automatically recycled. can set different combination patterns “vertical units” “horizontal units”. example, Peano curve different switch-back types (Hans Sagan, Space-Filling Curves, 1994 Springer, Figure 3.7.1)  Since pattern applied every level curve generation, want nine level-1 units pattern \"vvvhhhvvv\" applied level-1, first generate -v curve adjust 1-3, 7-8 subunits vertical 4-6 subunits horizontal.","code":"p = peano_curve(level = 4) draw_multiple_curves(     p |> sfc_grob() |> add_base_structure(level = 1),     p |> sfc_grob() |> add_base_structure(level = 2),     p |> sfc_grob() |> add_base_structure(level = 3),     sfc_reduce(p, 3) |> sfc_grob() |> add_base_structure(level = 1),     sfc_reduce(p, 3) |> sfc_grob() |> add_base_structure(level = 2),     grob(),  # a null grob, a place holder     sfc_reduce(p, 2) |> sfc_grob() |> add_base_structure(level = 1),     sfc_reduce(p, 1),     nrow = 3, lwd = 2, padding = unit(4, \"pt\")) draw_multiple_curves(     peano_curve(level = 3, pattern = \"vh\"),     peano_curve(level = 3, pattern = \"h\"),     peano_curve(level = 3, pattern = \"hv\"),     peano_curve(level = 3, pattern = \"vvvhhhvvv\"),     nrow = 2, lwd = 2, padding = unit(4, \"pt\")) p = sfc_peano(\"I\", level = 3, flip = function(p) {     p@rot %in% c(90, 270) }) p = sfc_apply(p, 2, function(u, i) {     if(i %% 9 %in% c(1, 2, 3, 7, 8, 9)) {         if(level1_unit_orientation(u) == \"horizontal\") {             sfc_flip_unit(u)         } else {             u         }     } else {         if(level1_unit_orientation(u) == \"vertical\") {             sfc_flip_unit(u)         } else {             u         }     } }) |> plot(lwd = 2)"},{"path":"/articles/standard_curves.html","id":"meander-curve","dir":"Articles","previous_headings":"3x3 standard curves","what":"Meander curve","title":"Standard curves","text":"Peano curve meander type (Hans Sagan, Space-Filling Curves, 1994 Springer, Figure 3.7.3). basic unit forms: forward (left) backward (right). thinking top part unit representing direction “wave”, forward means direction wave direction curve verse visa backward.  expanding rules draw_rules_meander() use “forward” unit patterns transverse code 1.  can also control individual directions level-1 units.","code":"p = meander_curve(level = 4) draw_multiple_curves(     p |> sfc_grob() |> add_base_structure(level = 1),     p |> sfc_grob() |> add_base_structure(level = 2),     p |> sfc_grob() |> add_base_structure(level = 3),     sfc_reduce(p, 3) |> sfc_grob() |> add_base_structure(level = 1),     sfc_reduce(p, 3) |> sfc_grob() |> add_base_structure(level = 2),     grob(),  # a null grob, a place holder     sfc_reduce(p, 2) |> sfc_grob() |> add_base_structure(level = 1),     sfc_reduce(p, 1),     nrow = 3, lwd = 2, padding = unit(4, \"pt\")) draw_multiple_curves(     meander_curve(level = 3, pattern = \"fb\"),     meander_curve(level = 3, pattern = \"fffffbbbb\"),     meander_curve(level = 3, pattern = \"b\"),     meander_curve(level = 3, pattern = \"fffbbb\"),     nrow = 2, lwd = 2, padding = unit(4, \"pt\"))"},{"path":"/articles/unit_flipping.html","id":"flip-individual-units","dir":"Articles","previous_headings":"","what":"Flip individual units","title":"Unit flipping","text":"unit certain level curve can independently flipped. unit specified “hierarchy index”. units organized hierarchical way curve. See following examples:  sfc_flip_unit() flips single unit list units. Whether diagonal flip vertical/horizontal flip automatically detected.","code":"par(mfrow = c(1, 3)) sfcurve:::test_sfc_index(p, \"\") # the complete curve sfcurve:::test_sfc_index(p, \"4\") sfcurve:::test_sfc_index(p, \"4:2\") p2 = sfc_flip_unit(p, \"7:3\") # the most topright 3x3 unit  p3 = sfc_flip_unit(p, as.character(1:9)) # every level-2 square units draw_multiple_curves(     p, p2, p3,      nrow = 1, lwd = 2)"},{"path":"/articles/unit_flipping.html","id":"flip-level-1-units","dir":"Articles","previous_headings":"","what":"Flip level-1 units","title":"Unit flipping","text":"helper function change_level1_unit_orientation() change orientation level-1 units simultaneously.  Note type flipping affect higher level structure. internally applies sfc_apply() depth sfc_level(p)-1 (.e. level = 1) introduced later sections.","code":"p2 = change_level1_unit_orientation(p,  \"vertical\") p3 = change_level1_unit_orientation(p,  \"horizontal\") draw_multiple_curves(     p, p2, p3,      nrow = 1, lwd = 2)"},{"path":"/articles/unit_flipping.html","id":"set-flipping-when-creating-the-curve","dir":"Articles","previous_headings":"","what":"Set flipping when creating the curve","title":"Unit flipping","text":"already shown vignette “Generalized Peano Curve”, sfc_peano() accepts argument flip self-defined function.  different change_level1_unit_orientation() applied level 1, self-defined function flip() appied every level curve.","code":"p2 = sfc_peano(\"I\", level = 3, flip = function(p) {     p@rot %in% c(90, 270) }) p3 = sfc_peano(\"I\", level = 3, flip = function(p) {     n = length(p)     l = rep(FALSE, n)     ind = seq(1, n/3)     l[ind] = p@rot[ind] %in% c(90, 270)      ind = seq(n/3+1, n/3*2)     l[ind] = p@rot[ind] %in% c(0, 180)      ind = seq(n/3*2+1, n)     l[ind] = p@rot[ind] %in% c(90, 270)     l }) draw_multiple_curves(p, p2, p3,      nrow = 1, lwd = 2)"},{"path":"/articles/unit_flipping.html","id":"adjust-flipping-on-a-generated-curve","dir":"Articles","previous_headings":"","what":"Adjust flipping on a generated curve","title":"Unit flipping","text":"can also adjust structure curve sfc_apply() certain depth. better control flipping patterns, use p2 level-1 units vertical.","code":"p3 = sfc_apply(p2, 1, function(x, i) {     if(i %% 2 == 1) {         sfc_flip_unit(x)     } else {         x     } }) p4 = sfc_apply(p2, 2, function(x, i) {     if(i %% 9 %in% 4:6) {         sfc_flip_unit(x, to = \"horizontal\")     } else {         x     } }) draw_multiple_curves(     p, p3, p4,      nrow = 1, lwd = 2)"},{"path":"/articles/unit_flipping.html","id":"seed-as-a-sequence","dir":"Articles","previous_headings":"","what":"Seed as a sequence","title":"Unit flipping","text":"sfc_flip_unit(), change_level1_unit_orientation() sfc_apply() work curves single letter seed internally use sfc_index() get subunits sfc_index() works square curves. “flip” function works seed sequence.","code":"sfc_peano(\"IJ\", level = 3, rot = 90, flip = function(p) {     p@rot %in% c(90, 270) }) |> plot()"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Zuguang Gu. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gu Z (2024). sfcurve: 2x2, 3x3 nxn Space-Filling Curves. R package version 1.0.0, https://github.com/jokergoo/sfcurve.","code":"@Manual{,   title = {sfcurve: 2x2, 3x3 and nxn Space-Filling Curves},   author = {Zuguang Gu},   year = {2024},   note = {R package version 1.0.0},   url = {https://github.com/jokergoo/sfcurve}, }"},{"path":"/index.html","id":"sfcurve-2x2-3x3-and-nxn-space-filling-curves","dir":"","previous_headings":"","what":"2x2, 3x3 and nxn Space-Filling Curves","title":"2x2, 3x3 and nxn Space-Filling Curves","text":"package provides way encode possible forms 2x2 3x3 space-filling curves. example, following eight forms correspond 2x2 curve level 3 R(0) (going-right base pattern rotation 0 degree) seed.  also supports nxn curves expanded specific level-1 units.","code":""},{"path":"/index.html","id":"install","dir":"","previous_headings":"","what":"Install","title":"2x2, 3x3 and nxn Space-Filling Curves","text":"","code":"devtools::install_github(\"jokergoo/sfcurve\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"2x2, 3x3 and nxn Space-Filling Curves","text":"Hilbert curve (2x2): Peano curve (3x3): Meander curve (3x3): also allows using sequence seed:","code":"> sfc_hilbert(\"I\", \"111\") An sfc_hilbert object.   Increase mode: 2 x 2   Level: 3   Expansion rule: Hilbert  A sequence of 64 base patterns.   R(0)L(270)L(0)R(90)     I(0)R(0)R(270)L(180)   L(270)R(0)R(270)I(180)  R(180)L(90)L(180)I(270)   .... other 4 lines ....   I(90)L(90)L(180)R(270)  I(180)R(180)R(90)L(0)   L(90)R(180)R(90)I(0)    R(0)L(270)L(0)R(90)  Seed: A sequence of 1 base pattern.   I(0) > sfc_peano(\"I\", \"111\") An sfc_peano object.   Increase mode: 3 x 3   Level: 3   Expansion rule: Peano  A sequence of 729 base patterns.   I(0)J(0)R(0)R(270)  I(180)L(180)L(270)J(0)   I(0)J(0)I(0)L(0)    L(90)J(180)R(180)R(90)   .... other 88 lines ....   I(0)J(0)R(0)R(270)  I(180)L(180)L(270)J(0)   I(0)  Seed: A sequence of 1 base pattern.   I(0) > sfc_meander(\"I\", \"111\") An sfc_meander object.   Increase mode: 3 x 3   Level: 3   Expansion rule: Meander  A sequence of 729 base patterns.   R(0)I(270)L(270)I(0)  L(0)L(90)R(180)R(90)   I(0)R(0)I(270)L(270)  I(0)L(0)L(90)R(180)   .... other 88 lines ....   R(0)I(270)L(270)I(0)  L(0)L(90)R(180)R(90)   I(0)  Seed: A sequence of 1 base pattern.   I(0) p = sfc_seed(\"LLLILILIILIILIIILIIILIIII\") p2 = sfc_hilbert(p, \"1111\") plot(p2)"},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"2x2, 3x3 and nxn Space-Filling Curves","text":"MIT @ Zuguang Gu","code":""},{"path":"/readme.html","id":null,"dir":"","previous_headings":"","what":"sfcurve: 2x2, 3x3 and nxn Space-Filling Curves","title":"sfcurve: 2x2, 3x3 and nxn Space-Filling Curves","text":"package provides way encode possible forms 2x2 3x3 space-filling curves. example, following eight forms correspond 2x2 curve level 3 R(0) (going-right base pattern rotation 0 degree) seed.  also supports nxn curves expanded specific level-1 units.","code":""},{"path":"/readme.html","id":"install","dir":"","previous_headings":"","what":"Install","title":"sfcurve: 2x2, 3x3 and nxn Space-Filling Curves","text":"","code":"devtools::install_github(\"jokergoo/sfcurve\")"},{"path":"/readme.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"sfcurve: 2x2, 3x3 and nxn Space-Filling Curves","text":"Hilbert curve (2x2): Peano curve (3x3): Meander curve (3x3): also allows using sequence seed:","code":"> sfc_hilbert(\"I\", \"111\") An sfc_hilbert object.   Increase mode: 2 x 2   Level: 3   Expansion rule: Hilbert  A sequence of 64 base patterns.   R(0)L(270)L(0)R(90)     I(0)R(0)R(270)L(180)   L(270)R(0)R(270)I(180)  R(180)L(90)L(180)I(270)   .... other 4 lines ....   I(90)L(90)L(180)R(270)  I(180)R(180)R(90)L(0)   L(90)R(180)R(90)I(0)    R(0)L(270)L(0)R(90)  Seed: A sequence of 1 base pattern.   I(0) > sfc_peano(\"I\", \"111\") An sfc_peano object.   Increase mode: 3 x 3   Level: 3   Expansion rule: Peano  A sequence of 729 base patterns.   I(0)J(0)R(0)R(270)  I(180)L(180)L(270)J(0)   I(0)J(0)I(0)L(0)    L(90)J(180)R(180)R(90)   .... other 88 lines ....   I(0)J(0)R(0)R(270)  I(180)L(180)L(270)J(0)   I(0)  Seed: A sequence of 1 base pattern.   I(0) > sfc_meander(\"I\", \"111\") An sfc_meander object.   Increase mode: 3 x 3   Level: 3   Expansion rule: Meander  A sequence of 729 base patterns.   R(0)I(270)L(270)I(0)  L(0)L(90)R(180)R(90)   I(0)R(0)I(270)L(270)  I(0)L(0)L(90)R(180)   .... other 88 lines ....   R(0)I(270)L(270)I(0)  L(0)L(90)R(180)R(90)   I(0)  Seed: A sequence of 1 base pattern.   I(0) p = sfc_seed(\"LLLILILIILIILIIILIIILIIII\") p2 = sfc_hilbert(p, \"1111\") plot(p2)"},{"path":"/readme.html","id":"license","dir":"","previous_headings":"","what":"License","title":"sfcurve: 2x2, 3x3 and nxn Space-Filling Curves","text":"MIT @ Zuguang Gu","code":""},{"path":"/reference/base_patterns.html","id":null,"dir":"Reference","previous_headings":"","what":"Base patterns — BASE_I","title":"Base patterns — BASE_I","text":"list pre-defined base patterns. See Examples section.","code":""},{"path":"/reference/base_patterns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Base patterns — BASE_I","text":"","code":"BASE_I  BASE_J  BASE_R  BASE_L  BASE_U  BASE_B  BASE_D  BASE_P  BASE_Q  BASE_C  BASE_LIST"},{"path":"/reference/base_patterns.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Base patterns — BASE_I","text":"object class sfc_base length 1. object class sfc_base length 1. object class sfc_base length 1. object class sfc_base length 1. object class sfc_base length 1. object class sfc_base length 1. object class sfc_base length 1. object class sfc_base length 1. object class sfc_base length 1. object class sfc_base length 1. object class list length 10.","code":""},{"path":"/reference/base_patterns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Base patterns — BASE_I","text":"BASE_I BASE_J identical. used distinguish two \"going forward\" patterns level-1 units 11/22 corner values, .e. bottom-left top-right, bottom-right top-left.","code":""},{"path":"/reference/base_patterns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Base patterns — BASE_I","text":"","code":"BASE_I #> Base: I, with 90 degrees in and 90 degrees out. BASE_J #> Base: J, with 90 degrees in and 90 degrees out. BASE_R #> Base: R, with 90 degrees in and 0 degrees out. BASE_L #> Base: L, with 90 degrees in and 180 degrees out. BASE_U #> Base: U, with 90 degrees in and 270 degrees out. BASE_B #> Base: B, with in-closed and 90 degrees out. BASE_D #> Base: D, with in-closed and 90 degrees out. BASE_P #> Base: P, with 90 degrees in and out-closed. BASE_Q #> Base: Q, with 90 degrees in and out-closed. BASE_C #> Base: C, self-closed. draw_multiple_curves(     BASE_I, BASE_J, BASE_R, BASE_L, BASE_U,     BASE_B, BASE_D, BASE_P, BASE_Q, BASE_C,     nrow = 2 )"},{"path":"/reference/draw_multiple_curves.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw multiple curves — draw_multiple_curves","title":"Draw multiple curves — draw_multiple_curves","text":"Draw multiple curves","code":""},{"path":"/reference/draw_multiple_curves.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw multiple curves — draw_multiple_curves","text":"","code":"draw_multiple_curves(   ...,   nrow = NULL,   ncol = NULL,   extend = TRUE,   title = FALSE,   closed = FALSE,   padding = unit(0, \"pt\"),   lwd = 4,   col = NULL )"},{"path":"/reference/draw_multiple_curves.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw multiple curves — draw_multiple_curves","text":"... list sfc_sequence objects objects child classes, list grid::grob objects list two-column coordinate matrices. .e., forms can represent curves package. nrow Number rows layout. ncol Number columns layout. extend Whether draw entering leaving segments? used input list sfc_sequence objects. title Whether add titles panel? title constructed form initial_seed|expansion_codes, e.g. |111. value can vector user-defined strings. closed Whether curves closed? value logical vector. TRUE, last point connected first point curve form closed curve. padding Space around curve. value grid::unit object. lwd Line width. col Color segments. value NULL, uses \"Spectral\" color palettes RColorBrewer package.","code":""},{"path":"/reference/draw_multiple_curves.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw multiple curves — draw_multiple_curves","text":"function used quick comparison curves.","code":""},{"path":"/reference/draw_multiple_curves.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw multiple curves — draw_multiple_curves","text":"","code":"# for all forms of curves initialized by base pattern 'R', with rotation 0, and on level 3 draw_multiple_curves(     sfc_hilbert(\"R\", \"111\"),     sfc_hilbert(\"R\", \"112\"),     sfc_hilbert(\"R\", \"121\"),     sfc_hilbert(\"R\", \"122\"),     sfc_hilbert(\"R\", \"211\"),     sfc_hilbert(\"R\", \"212\"),     sfc_hilbert(\"R\", \"221\"),     sfc_hilbert(\"R\", \"222\"),     nrow = 2, title = TRUE)   # simply a list of sequences # note they only contain I/R/L, so the base patterns I/R/L are internally used draw_multiple_curves(     sfc_sequence(\"IIII\"),     sfc_sequence(\"RRRR\"),     sfc_sequence(\"RRLL\"),     nrow = 1 )"},{"path":"/reference/draw_rules.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw the expansion rules — draw_rules_hilbert","title":"Draw the expansion rules — draw_rules_hilbert","text":"Draw expansion rules","code":""},{"path":"/reference/draw_rules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw the expansion rules — draw_rules_hilbert","text":"","code":"draw_rules_hilbert()  draw_rules_peano(flip = FALSE)  draw_rules_meander(flip = FALSE)"},{"path":"/reference/draw_rules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw the expansion rules — draw_rules_hilbert","text":"flip Whether use \"flipped\" rules? Peano curve Meander curve, also \"fliiped\" version curve expansion rules. See vignettes details.","code":""},{"path":"/reference/draw_rules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw the expansion rules — draw_rules_hilbert","text":"expansion rules define curve expanded level-0 level-1.","code":""},{"path":"/reference/draw_rules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw the expansion rules — draw_rules_hilbert","text":"","code":"draw_rules_hilbert()  # the units in the main rules of the Peano curve are vertical draw_rules_peano()  # the units in the flipped rules of the Peano curve are horizontal draw_rules_peano(flip = TRUE)  # the units in the main rules of the Meander curve are \"forward\" # i.e. the direction of the \"wave\" is the same as the direction of the curve draw_rules_meander()  # the units in the flipped rules of the Meander curve are \"backward\" draw_rules_meander(flip = TRUE)"},{"path":"/reference/h_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"H-curve — sfc_h","title":"H-curve — sfc_h","text":"H-curve","code":""},{"path":"/reference/h_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"H-curve — sfc_h","text":"","code":"sfc_h(h, iteration = 1, connect = c(\"h\", \"v\"), random = FALSE)  expand_h(h1, h2 = h1, h3 = h1, h4 = h1, connect = \"hhhh\")"},{"path":"/reference/h_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"H-curve — sfc_h","text":"h seed H-curve. value one H0, H1 H2. iteration Number iterations. connect four subunits connected form H-curve next level. See Details. random Whether generate subunits randomly iteration. h1 first subunit. h2 second subunit. h3 third subunit. h4 fourth subunit.","code":""},{"path":"/reference/h_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"H-curve — sfc_h","text":"two-column matrix coordinates points curve.","code":""},{"path":"/reference/h_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"H-curve — sfc_h","text":"H-curve level k composed four subunits level k-1. number four subunits following order:   subunit 1 connects subunit 2, subunit 2 connects subunit 3, et al., e.g. subunit 1 connects subunit 2 via toprigth corner. Since H-curve can thought closed curve, , e.g. let subunit 1 connect subunit 2, topright corner needs opened. two segments subunit 1 can removed/opened: horiozntal segment vertical segment topright corner subunit 1. way, sfc_h(), argument connect accepts single value \"h\" \"v\" types segments four subunits , .e. whether horizontal corner segments opened whether vertical corner segments opened. expand_h(), argument connect can set vector length four type segments four subunits can set separately. random mode, subunit generated randomly, type open segment choosen randomly, also subunit probability 0.5 rotate 90 degrees.","code":"2  3 1  4"},{"path":"/reference/h_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"H-curve — sfc_h","text":"","code":"draw_multiple_curves(     sfc_h(H0, iteration = 2),     sfc_h(H2, iteration = 2),     closed = TRUE, nrow =1 )  draw_multiple_curves(     sfc_h(H1, iteration = 3, random = TRUE),     sfc_h(H1, iteration = 3, random = TRUE),     closed = TRUE, nrow = 1 )  draw_multiple_curves(     expand_h(H0, connect = \"hvvh\"),     expand_h(H1, connect = \"vvhh\"),     closed = TRUE, nrow = 1 )   # set the four subunits separately h1 = expand_h(H0, connect = \"hhhh\") h2 = expand_h(H0, connect = \"vvvv\") h3 = expand_h(H0, connect = \"hvhv\") h4 = expand_h(H0, connect = \"hvvh\") expand_h(h1, h2, h3, h4, connect = \"vhvh\") |>      plot_segments(closed = TRUE)   fun = function(h, k) {     for(i in 1:k) h = expand_h(h, connect = \"vhvh\")     h } fun(H0, 4) |> plot_segments(closed = TRUE)"},{"path":"/reference/h_seed.html","id":null,"dir":"Reference","previous_headings":"","what":"Seed sequences of the H-curve — H0","title":"Seed sequences of the H-curve — H0","text":"Seed sequences H-curve","code":""},{"path":"/reference/h_seed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Seed sequences of the H-curve — H0","text":"","code":"H0  H1  H2"},{"path":"/reference/h_seed.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Seed sequences of the H-curve — H0","text":"object class matrix (inherits array) 4 rows 2 columns. object class matrix (inherits array) 16 rows 2 columns. object class matrix (inherits array) 16 rows 2 columns.","code":""},{"path":"/reference/h_seed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Seed sequences of the H-curve — H0","text":"three objects simply contain coordinates points three base curves.","code":""},{"path":"/reference/h_seed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Seed sequences of the H-curve — H0","text":"","code":"H0 #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    1 #> [3,]    1    1 #> [4,]    1    0 draw_multiple_curves(H0, H1, H2, nrow = 1, closed = TRUE)"},{"path":"/reference/hilbert_3d.html","id":null,"dir":"Reference","previous_headings":"","what":"Three dimensional Hilbert curve — hilbert_3d","title":"Three dimensional Hilbert curve — hilbert_3d","text":"Three dimensional Hilbert curve","code":""},{"path":"/reference/hilbert_3d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Three dimensional Hilbert curve — hilbert_3d","text":"","code":"hilbert_3d(level = 2L)"},{"path":"/reference/hilbert_3d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Three dimensional Hilbert curve — hilbert_3d","text":"level level curve.","code":""},{"path":"/reference/hilbert_3d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Three dimensional Hilbert curve — hilbert_3d","text":"three-column matrix coordinates points 3D Hilbert curve","code":""},{"path":"/reference/hilbert_3d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Three dimensional Hilbert curve — hilbert_3d","text":"many forms 3D Hilbert curve. implement one specific form .","code":""},{"path":[]},{"path":"/reference/hilbert_3d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Three dimensional Hilbert curve — hilbert_3d","text":"","code":"pos = hilbert_3d(2) if(require(rgl) && interactive()) {     plot3d(pos, type = \"l\", lwd = 4, col = 2) } #> Loading required package: rgl"},{"path":"/reference/level1_unit.html","id":null,"dir":"Reference","previous_headings":"","what":"Level-1 unit in the Peano curve — level1_unit_orientation,sfc_peano-method","title":"Level-1 unit in the Peano curve — level1_unit_orientation,sfc_peano-method","text":"Level-1 unit Peano curve","code":""},{"path":"/reference/level1_unit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Level-1 unit in the Peano curve — level1_unit_orientation,sfc_peano-method","text":"","code":"# S4 method for sfc_peano level1_unit_orientation(p)  # S4 method for sfc_peano change_level1_unit_orientation(p, to = c(\"horizontal\", \"vertical\"))"},{"path":"/reference/level1_unit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Level-1 unit in the Peano curve — level1_unit_orientation,sfc_peano-method","text":"p level1_unit_orientation(), sfc_peano unit level-1. change_level1_unit_orientation(), normal sfc_peano object. string \"vertical\" \"horizontal\".","code":""},{"path":"/reference/level1_unit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Level-1 unit in the Peano curve — level1_unit_orientation,sfc_peano-method","text":"level1_unit_orientation() returns \"vertical\" \"horizontal\". change_level1_unit_orientation() returns sfc_peano object.","code":""},{"path":"/reference/level1_unit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Level-1 unit in the Peano curve — level1_unit_orientation,sfc_peano-method","text":"level1_unit_orientation() normally used inside sfc_apply(). change_level1_unit_orientation() changes level-1 units Peano curves simultaneously.","code":""},{"path":"/reference/level1_unit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Level-1 unit in the Peano curve — level1_unit_orientation,sfc_peano-method","text":"","code":"p = sfc_peano(\"I\", 111) level1_unit_orientation(p[1:9, TRUE]) #> [1] \"vertical\" level1_unit_orientation(p[1:9 + 27, TRUE]) #> [1] \"horizontal\" p2 = change_level1_unit_orientation(p) p3 = change_level1_unit_orientation(p, \"vertical\") draw_multiple_curves(p, p2, p3,      title = c(\"original\", \"all horizontal\", \"all vertical\"), nrow = 1)"},{"path":"/reference/plot_segments.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot segments — plot_segments","title":"Plot segments — plot_segments","text":"Plot segments","code":""},{"path":"/reference/plot_segments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot segments — plot_segments","text":"","code":"plot_segments(x, grid = FALSE, title = FALSE, closed = FALSE, ...)"},{"path":"/reference/plot_segments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot segments — plot_segments","text":"x two-column matrix coordinates points. grid Whether add grid lines plot? title value FALSE string. closed Whether curve closed? ... arguments passed sfc_grob().","code":""},{"path":"/reference/plot_segments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot segments — plot_segments","text":"function quick demonstration curves represented two-column coordinate matrices.","code":""},{"path":"/reference/pre_defined_rules.html","id":null,"dir":"Reference","previous_headings":"","what":"Rules — SFC_RULES_HILBERT","title":"Rules — SFC_RULES_HILBERT","text":"list pre-defined expansion rules different curves.","code":""},{"path":"/reference/pre_defined_rules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rules — SFC_RULES_HILBERT","text":"","code":"SFC_RULES_HILBERT  SFC_RULES_PEANO  SFC_RULES_MEANDER  SFC_RULES_3x3_COMBINED  SFC_RULES_4x4_MEANDER_1  SFC_RULES_4x4_MEANDER_2"},{"path":"/reference/pre_defined_rules.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rules — SFC_RULES_HILBERT","text":"object class sfc_rules length 1. object class sfc_rules length 1. object class sfc_rules length 1. object class sfc_rules length 1. object class sfc_rules length 1. object class sfc_rules length 1.","code":""},{"path":"/reference/pre_defined_rules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rules — SFC_RULES_HILBERT","text":"SFC_RULES_PEANO, SFC_RULES_MEANDER SFC_RULES_3x3_COMBINED, SFC_RULES_MEANDER_4x4_1, SFC_RULES_MEANDER_4x4_2 also contain \"flipped\" expansion rules. SFC_RULES_3x3_COMBINED combination SFC_RULES_PEANO SFC_RULES_PEANO SFC_RULES_PEANO, J replaced original pattern . SFC_RULES_4x4_MEANDER_1 SFC_RULES_4x4_MEANDER_2 extension rules SFC_RULES_MEANDER 4x4 curve. demonstration purpose, thus /R/L supported.","code":""},{"path":"/reference/pre_defined_rules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rules — SFC_RULES_HILBERT","text":"","code":"SFC_RULES_HILBERT #> Name: Hilbert #> I | I_1 = R(0)L(270)L(0)R(90)    corner = (1, 2)  #>     I_2 = L(0)R(90)R(0)L(270)    corner = (2, 1)  #> R | R_1 = I(0)R(0)R(270)L(180)   corner = (1, 2)  #>     R_2 = L(0)R(90)R(0)I(270)    corner = (2, 1)  #> L | L_1 = R(0)L(270)L(0)I(90)    corner = (1, 2)  #>     L_2 = I(0)L(0)L(90)R(180)    corner = (2, 1)  #> U | U_1 = I(0)R(0)R(270)I(180)   corner = (1, 2)  #>     U_2 = I(0)L(0)L(90)I(180)    corner = (2, 1)  #> B | B_1 = R(270)R(180)R(90)I(0)  corner = (1, 2)  #>     B_2 = L(180)L(270)L(0)R(90)  corner = (1, 2)  #> D | D_1 = L(90)L(180)L(270)I(0)  corner = (2, 1)  #>     D_2 = R(180)R(90)R(0)L(270)  corner = (2, 1)  #> P | P_1 = I(0)R(0)R(270)R(180)   corner = (1, 2)  #>     P_2 = R(0)L(270)L(0)L(90)    corner = (1, 2)  #> Q | Q_1 = I(0)L(0)L(90)L(180)    corner = (2, 1)  #>     Q_2 = L(0)R(90)R(0)R(270)    corner = (2, 1)  #> C | C_1 = L(0)L(90)L(180)L(270)  corner = (1, 2)  #>     C_2 = R(0)R(270)R(180)R(90)  corner = (2, 1)  SFC_RULES_PEANO #> Name: Peano #> I | I_1 = I(0)J(0)R(0)R(270)I(180)L(180)L(270)J(0)I(0)  corner = (1, 1)  #> J | J_1 = J(0)I(0)L(0)L(90)J(180)R(180)R(90)I(0)J(0)    corner = (2, 2)  #> R | R_1 = I(0)J(0)R(0)R(270)I(180)L(180)L(270)J(0)R(0)  corner = (1, 1)  #> L | L_1 = J(0)I(0)L(0)L(90)J(180)R(180)R(90)I(0)L(0)    corner = (2, 2)  #>  #> Flipped: #> I | I_1 = R(0)I(270)L(270)L(0)J(90)R(90)R(0)I(270)L(270)  corner = (1, 1)  #> J | J_1 = L(0)J(90)R(90)R(0)I(270)L(270)L(0)J(90)R(90)    corner = (2, 2)  #> R | R_1 = R(0)I(270)L(270)L(0)J(90)R(90)R(0)I(270)J(270)  corner = (1, 1)  #> L | L_1 = L(0)J(90)R(90)R(0)I(270)L(270)L(0)J(90)I(90)    corner = (2, 2)  SFC_RULES_MEANDER #> Name: Meander #> I | I_1 = R(0)I(270)L(270)I(0)L(0)L(90)R(180)R(90)I(0)      corner = (1, 2)  #>     I_2 = L(0)I(90)R(90)I(0)R(0)R(270)L(180)L(270)I(0)      corner = (2, 1)  #> R | R_1 = I(0)I(0)R(0)I(270)R(270)R(180)L(90)L(180)I(270)   corner = (1, 2)  #>     R_2 = L(0)I(90)R(90)I(0)R(0)R(270)L(180)L(270)R(0)      corner = (2, 1)  #> L | L_1 = R(0)I(270)L(270)I(0)L(0)L(90)R(180)R(90)L(0)      corner = (1, 2)  #>     L_2 = I(0)I(0)L(0)I(90)L(90)L(180)R(270)R(180)I(90)     corner = (2, 1)  #> U | U_1 = I(0)I(0)R(0)I(270)R(270)R(180)L(90)L(180)R(270)   corner = (1, 2)  #>     U_2 = I(0)I(0)L(0)I(90)L(90)L(180)R(270)R(180)L(90)     corner = (2, 1)  #> B | B_1 = L(180)I(270)L(270)I(0)L(0)L(90)R(180)R(90)I(0)    corner = (1, 2)  #>     B_2 = R(270)I(180)R(180)I(90)R(90)R(0)L(270)L(0)R(90)   corner = (1, 2)  #> D | D_1 = L(90)I(180)L(180)I(270)L(270)L(0)R(90)R(0)L(270)  corner = (2, 1)  #>     D_2 = R(180)I(90)R(90)I(0)R(0)R(270)L(180)L(270)I(0)    corner = (2, 1)  #> P | P_1 = I(0)I(0)R(0)I(270)R(270)R(180)L(90)L(180)L(270)   corner = (1, 2)  #>     P_2 = R(0)I(270)L(270)I(0)L(0)L(90)R(180)R(90)R(0)      corner = (1, 2)  #> Q | Q_1 = I(0)I(0)L(0)I(90)L(90)L(180)R(270)R(180)R(90)     corner = (2, 1)  #>     Q_2 = L(0)I(90)R(90)I(0)R(0)R(270)L(180)L(270)L(0)      corner = (2, 1)  #> C | C_1 = L(0)I(90)L(90)I(180)L(180)L(270)R(0)R(270)R(180)  corner = (1, 2)  #>     C_2 = R(0)I(270)R(270)I(180)R(180)R(90)L(0)L(90)L(180)  corner = (2, 1)  #>  #> Flipped: #> I | I_1 = I(0)R(0)R(270)L(180)L(270)I(0)L(0)I(90)R(90)        corner = (1, 2)  #>     I_2 = I(0)L(0)L(90)R(180)R(90)I(0)R(0)I(270)L(270)        corner = (2, 1)  #> R | R_1 = R(0)L(270)L(0)R(90)R(0)I(270)R(270)I(180)L(180)     corner = (1, 2)  #>     R_2 = I(0)L(0)L(90)R(180)R(90)I(0)R(0)I(270)I(270)        corner = (2, 1)  #> L | L_1 = I(0)R(0)R(270)L(180)L(270)I(0)L(0)I(90)I(90)        corner = (1, 2)  #>     L_2 = L(0)R(90)R(0)L(270)L(0)I(90)L(90)I(180)R(180)       corner = (2, 1)  #> U | U_1 = R(0)L(270)L(0)R(90)R(0)I(270)R(270)I(180)I(180)     corner = (1, 2)  #>     U_2 = L(0)R(90)R(0)L(270)L(0)I(90)L(90)I(180)I(180)       corner = (2, 1)  #> B | B_1 = R(90)R(0)R(270)L(180)L(270)I(0)L(0)I(90)R(90)       corner = (1, 2)  #>     B_2 = L(0)L(90)L(180)R(270)R(180)I(90)R(90)I(0)I(0)       corner = (1, 2)  #> D | D_1 = R(0)R(270)R(180)L(90)L(180)I(270)L(270)I(0)I(0)     corner = (2, 1)  #>     D_2 = L(270)L(0)L(90)R(180)R(90)I(0)R(0)I(270)L(270)      corner = (2, 1)  #> P | P_1 = R(0)L(270)L(0)R(90)R(0)I(270)R(270)I(180)R(180)     corner = (1, 2)  #>     P_2 = I(0)R(0)R(270)L(180)L(270)I(0)L(0)I(90)L(90)        corner = (1, 2)  #> Q | Q_1 = L(0)R(90)R(0)L(270)L(0)I(90)L(90)I(180)L(180)       corner = (2, 1)  #>     Q_2 = I(0)L(0)L(90)R(180)R(90)I(0)R(0)I(270)R(270)        corner = (2, 1)  #> C | C_1 = R(270)R(180)R(90)L(0)L(90)I(180)L(180)I(270)L(270)  corner = (1, 2)  #>     C_2 = L(90)L(180)L(270)R(0)R(270)I(180)R(180)I(90)R(90)   corner = (2, 1)  SFC_RULES_3x3_COMBINED #> Name: 3x3_combined #> I | I_1 = R(0)I(270)L(270)I(0)L(0)L(90)R(180)R(90)I(0)      corner = (1, 2)  #>     I_2 = L(0)I(90)R(90)I(0)R(0)R(270)L(180)L(270)I(0)      corner = (2, 1)  #>     I_3 = I(0)I(0)R(0)R(270)I(180)L(180)L(270)I(0)I(0)      corner = (1, 1)  #>     I_4 = I(0)I(0)L(0)L(90)I(180)R(180)R(90)I(0)I(0)        corner = (2, 2)  #> R | R_1 = I(0)I(0)R(0)I(270)R(270)R(180)L(90)L(180)I(270)   corner = (1, 2)  #>     R_2 = L(0)I(90)R(90)I(0)R(0)R(270)L(180)L(270)R(0)      corner = (2, 1)  #>     R_3 = I(0)I(0)R(0)R(270)I(180)L(180)L(270)I(0)R(0)      corner = (1, 1)  #> L | L_1 = R(0)I(270)L(270)I(0)L(0)L(90)R(180)R(90)L(0)      corner = (1, 2)  #>     L_2 = I(0)I(0)L(0)I(90)L(90)L(180)R(270)R(180)I(90)     corner = (2, 1)  #>     L_3 = I(0)I(0)L(0)L(90)I(180)R(180)R(90)I(0)L(0)        corner = (2, 2)  #> U | U_1 = I(0)I(0)R(0)I(270)R(270)R(180)L(90)L(180)R(270)   corner = (1, 2)  #>     U_2 = I(0)I(0)L(0)I(90)L(90)L(180)R(270)R(180)L(90)     corner = (2, 1)  #> B | B_1 = L(180)I(270)L(270)I(0)L(0)L(90)R(180)R(90)I(0)    corner = (1, 2)  #>     B_2 = R(270)I(180)R(180)I(90)R(90)R(0)L(270)L(0)R(90)   corner = (1, 2)  #>     B_3 = L(270)I(0)L(0)L(90)I(180)R(180)R(90)I(0)I(0)      corner = (2, 2)  #> D | D_1 = L(90)I(180)L(180)I(270)L(270)L(0)R(90)R(0)L(270)  corner = (2, 1)  #>     D_2 = R(180)I(90)R(90)I(0)R(0)R(270)L(180)L(270)I(0)    corner = (2, 1)  #>     D_3 = R(90)I(0)R(0)R(270)I(180)L(180)L(270)I(0)I(0)     corner = (1, 1)  #> P | P_1 = I(0)I(0)R(0)I(270)R(270)R(180)L(90)L(180)L(270)   corner = (1, 2)  #>     P_2 = R(0)I(270)L(270)I(0)L(0)L(90)R(180)R(90)R(0)      corner = (1, 2)  #>     P_3 = I(0)I(0)R(0)R(270)I(180)L(180)L(270)I(0)L(0)      corner = (1, 1)  #> Q | Q_1 = I(0)I(0)L(0)I(90)L(90)L(180)R(270)R(180)R(90)     corner = (2, 1)  #>     Q_2 = L(0)I(90)R(90)I(0)R(0)R(270)L(180)L(270)L(0)      corner = (2, 1)  #>     Q_3 = I(0)I(0)L(0)L(90)I(180)R(180)R(90)I(0)R(0)        corner = (2, 2)  #> C | C_1 = L(0)I(90)L(90)I(180)L(180)L(270)R(0)R(270)R(180)  corner = (1, 2)  #>     C_2 = R(0)I(270)R(270)I(180)R(180)R(90)L(0)L(90)L(180)  corner = (2, 1)  #>     C_3 = R(90)I(0)R(0)R(270)I(180)L(180)L(270)I(0)L(0)     corner = (1, 1)  #>     C_4 = L(270)I(0)L(0)L(90)I(180)R(180)R(90)I(0)R(0)      corner = (2, 2)  #>  #> Flipped: #> I | I_1 = I(0)R(0)R(270)L(180)L(270)I(0)L(0)I(90)R(90)        corner = (1, 2)  #>     I_2 = I(0)L(0)L(90)R(180)R(90)I(0)R(0)I(270)L(270)        corner = (2, 1)  #>     I_3 = R(0)I(270)L(270)L(0)I(90)R(90)R(0)I(270)L(270)      corner = (1, 1)  #>     I_4 = L(0)I(90)R(90)R(0)I(270)L(270)L(0)I(90)R(90)        corner = (2, 2)  #> R | R_1 = R(0)L(270)L(0)R(90)R(0)I(270)R(270)I(180)L(180)     corner = (1, 2)  #>     R_2 = I(0)L(0)L(90)R(180)R(90)I(0)R(0)I(270)I(270)        corner = (2, 1)  #>     R_3 = R(0)I(270)L(270)L(0)I(90)R(90)R(0)I(270)I(270)      corner = (1, 1)  #> L | L_1 = I(0)R(0)R(270)L(180)L(270)I(0)L(0)I(90)I(90)        corner = (1, 2)  #>     L_2 = L(0)R(90)R(0)L(270)L(0)I(90)L(90)I(180)R(180)       corner = (2, 1)  #>     L_3 = L(0)I(90)R(90)R(0)I(270)L(270)L(0)I(90)I(90)        corner = (2, 2)  #> U | U_1 = R(0)L(270)L(0)R(90)R(0)I(270)R(270)I(180)I(180)     corner = (1, 2)  #>     U_2 = L(0)R(90)R(0)L(270)L(0)I(90)L(90)I(180)I(180)       corner = (2, 1)  #> B | B_1 = R(90)R(0)R(270)L(180)L(270)I(0)L(0)I(90)R(90)       corner = (1, 2)  #>     B_2 = L(0)L(90)L(180)R(270)R(180)I(90)R(90)I(0)I(0)       corner = (1, 2)  #>     B_3 = U(270)I(90)R(90)R(0)I(270)L(270)L(0)I(90)R(90)      corner = (2, 2)  #> D | D_1 = R(0)R(270)R(180)L(90)L(180)I(270)L(270)I(0)I(0)     corner = (2, 1)  #>     D_2 = L(270)L(0)L(90)R(180)R(90)I(0)R(0)I(270)L(270)      corner = (2, 1)  #>     D_3 = U(90)I(270)L(270)L(0)I(90)R(90)R(0)I(270)L(270)     corner = (1, 1)  #> P | P_1 = R(0)L(270)L(0)R(90)R(0)I(270)R(270)I(180)R(180)     corner = (1, 2)  #>     P_2 = I(0)R(0)R(270)L(180)L(270)I(0)L(0)I(90)L(90)        corner = (1, 2)  #>     P_3 = R(0)I(270)L(270)L(0)I(90)R(90)R(0)I(270)U(270)      corner = (1, 1)  #> Q | Q_1 = L(0)R(90)R(0)L(270)L(0)I(90)L(90)I(180)L(180)       corner = (2, 1)  #>     Q_2 = I(0)L(0)L(90)R(180)R(90)I(0)R(0)I(270)R(270)        corner = (2, 1)  #>     Q_3 = L(0)I(90)R(90)R(0)I(270)L(270)L(0)I(90)U(90)        corner = (2, 2)  #> C | C_1 = R(270)R(180)R(90)L(0)L(90)I(180)L(180)I(270)L(270)  corner = (1, 2)  #>     C_2 = L(90)L(180)L(270)R(0)R(270)I(180)R(180)I(90)R(90)   corner = (2, 1)  #>     C_3 = U(90)I(270)L(270)L(0)I(90)R(90)R(0)I(270)U(270)     corner = (1, 1)  #>     C_4 = U(270)I(90)R(90)R(0)I(270)L(270)L(0)I(90)U(90)      corner = (2, 2)  SFC_RULES_4x4_MEANDER_1 #> Name: Meander 4x4 type 1 #> I | I_1 = I(0)I(0)R(0)I(270)R(270)R(180)L(90)L(180)I(270)L(270)I(0)I(0)L(0)I(90)I(90)R(90)      corner = (1, 2)  #>     I_2 = I(0)I(0)L(0)I(90)L(90)L(180)R(270)R(180)I(90)R(90)I(0)I(0)R(0)I(270)I(270)L(270)      corner = (2, 1)  #> R | R_1 = R(0)I(270)L(270)I(0)L(0)L(90)R(180)R(90)I(0)R(0)I(270)I(270)R(270)I(180)I(180)L(180)  corner = (1, 2)  #>     R_2 = I(0)I(0)L(0)I(90)L(90)L(180)R(270)R(180)I(90)R(90)I(0)I(0)R(0)I(270)I(270)I(270)      corner = (2, 1)  #> L | L_1 = I(0)I(0)R(0)I(270)R(270)R(180)L(90)L(180)I(270)L(270)I(0)I(0)L(0)I(90)I(90)I(90)      corner = (1, 2)  #>     L_2 = L(0)I(90)R(90)I(0)R(0)R(270)L(180)L(270)I(0)L(0)I(90)I(90)L(90)I(180)I(180)R(180)     corner = (2, 1)  #>  #> Flipped: #> I | I_1 = R(0)I(270)I(270)L(270)I(0)I(0)L(0)I(90)L(90)L(180)R(270)R(180)I(90)R(90)I(0)I(0)      corner = (1, 2)  #>     I_2 = L(0)I(90)I(90)R(90)I(0)I(0)R(0)I(270)R(270)R(180)L(90)L(180)I(270)L(270)I(0)I(0)      corner = (2, 1)  #> R | R_1 = I(0)I(0)I(0)R(0)I(270)I(270)R(270)I(180)R(180)R(90)L(0)L(90)I(180)L(180)I(270)I(270)  corner = (1, 2)  #>     R_2 = L(0)I(90)I(90)R(90)I(0)I(0)R(0)I(270)R(270)R(180)L(90)L(180)I(270)L(270)I(0)R(0)      corner = (2, 1)  #> L | L_1 = R(0)I(270)I(270)L(270)I(0)I(0)L(0)I(90)L(90)L(180)R(270)R(180)I(90)R(90)I(0)L(0)      corner = (1, 2)  #>     L_2 = I(0)I(0)I(0)L(0)I(90)I(90)L(90)I(180)L(180)L(270)R(0)R(270)I(180)R(180)I(90)I(90)     corner = (2, 1)  SFC_RULES_4x4_MEANDER_2 #> Name: Meander 4x4 type 2 #> I | I_1 = R(0)I(270)I(270)L(270)I(0)I(0)L(0)L(90)I(180)R(180)I(90)R(90)R(0)L(270)L(0)R(90)      corner = (1, 2)  #>     I_2 = L(0)I(90)I(90)R(90)I(0)I(0)R(0)R(270)I(180)L(180)I(270)L(270)L(0)R(90)R(0)L(270)      corner = (2, 1)  #> R | R_1 = I(0)I(0)I(0)R(0)I(270)I(270)R(270)R(180)I(90)L(90)I(180)L(180)L(270)R(0)R(270)L(180)  corner = (1, 2)  #>     R_2 = L(0)I(90)I(90)R(90)I(0)I(0)R(0)R(270)I(180)L(180)I(270)L(270)L(0)R(90)R(0)I(270)      corner = (2, 1)  #> L | L_1 = R(0)I(270)I(270)L(270)I(0)I(0)L(0)L(90)I(180)R(180)I(90)R(90)R(0)L(270)L(0)I(90)      corner = (1, 2)  #>     L_2 = I(0)I(0)I(0)L(0)I(90)I(90)L(90)L(180)I(270)R(270)I(180)R(180)R(90)L(0)L(90)R(180)     corner = (2, 1)  #>  #> Flipped: #> I | I_1 = R(0)L(270)L(0)R(90)R(0)I(270)R(270)I(180)L(180)L(270)I(0)I(0)L(0)I(90)I(90)R(90)      corner = (1, 2)  #>     I_2 = L(0)R(90)R(0)L(270)L(0)I(90)L(90)I(180)R(180)R(90)I(0)I(0)R(0)I(270)I(270)L(270)      corner = (2, 1)  #> R | R_1 = I(0)R(0)R(270)L(180)L(270)I(0)L(0)I(90)R(90)R(0)I(270)I(270)R(270)I(180)I(180)L(180)  corner = (1, 2)  #>     R_2 = L(0)R(90)R(0)L(270)L(0)I(90)L(90)I(180)R(180)R(90)I(0)I(0)R(0)I(270)I(270)I(270)      corner = (2, 1)  #> L | L_1 = R(0)L(270)L(0)R(90)R(0)I(270)R(270)I(180)L(180)L(270)I(0)I(0)L(0)I(90)I(90)I(90)      corner = (1, 2)  #>     L_2 = I(0)L(0)L(90)R(180)R(90)I(0)R(0)I(270)L(270)L(0)I(90)I(90)L(90)I(180)I(180)R(180)     corner = (2, 1)"},{"path":"/reference/sfc_3x3_combined.html","id":null,"dir":"Reference","previous_headings":"","what":"General 3x3 space-filling curves — sfc_3x3_combined","title":"General 3x3 space-filling curves — sfc_3x3_combined","text":"General 3x3 space-filling curves","code":""},{"path":"/reference/sfc_3x3_combined.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"General 3x3 space-filling curves — sfc_3x3_combined","text":"","code":"sfc_3x3_combined(seed, level = 0, rot = 0L, flip = FALSE)  # S4 method for sfc_3x3_combined sfc_expand(p, code = NULL, flip = FALSE)  draw_rules_3x3_combined(flip = FALSE)"},{"path":"/reference/sfc_3x3_combined.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"General 3x3 space-filling curves — sfc_3x3_combined","text":"seed seed sequence. cases, seed sequence single base pattern, can specified single letter, rot controls initial rotation base pattern. also supports sequence one base patterns seed sequence. case, can specified string one base letters, rot can set single rotation scalar controls rotation first letter, vector length number base letters. level Level curve. Currently restricted integer smaller 6. rot Rotation seed sequence, measured polar coordinate system, degrees. flip setting sfc_peano() sfc_meander(). p sfc_3x3_combined object. code Ignore. transverse code selected randomly.","code":""},{"path":"/reference/sfc_3x3_combined.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"General 3x3 space-filling curves — sfc_3x3_combined","text":"type 3x3 curve uses combintation base patterns Peano curve Meander curve. level, transverse path randomly selected.","code":""},{"path":"/reference/sfc_3x3_combined.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"General 3x3 space-filling curves — sfc_3x3_combined","text":"","code":"draw_multiple_curves(     sfc_3x3_combined(\"I\", level = 3),     sfc_3x3_combined(\"I\", level = 3),     sfc_3x3_combined(\"I\", level = 3),     nrow = 1 )  draw_rules_3x3_combined()  draw_rules_3x3_combined(flip = TRUE)"},{"path":"/reference/sfc_4x4_meander.html","id":null,"dir":"Reference","previous_headings":"","what":"4x4 space-filling curves in meander type — sfc_4x4_meander","title":"4x4 space-filling curves in meander type — sfc_4x4_meander","text":"4x4 space-filling curves meander type","code":""},{"path":"/reference/sfc_4x4_meander.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"4x4 space-filling curves in meander type — sfc_4x4_meander","text":"","code":"sfc_4x4_meander(seed, code = integer(0), rot = 0L, flip = FALSE, type = 1L)  # S4 method for sfc_4x4_meander sfc_expand(p, code, flip = FALSE)  draw_rules_4x4_meander(type = 1, flip = FALSE)"},{"path":"/reference/sfc_4x4_meander.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"4x4 space-filling curves in meander type — sfc_4x4_meander","text":"seed seed sequence. cases, seed sequence single base pattern, can specified single letter, rot controls initial rotation base pattern. also supports sequence one base patterns seed sequence. case, can specified string one base letters, rot can set single rotation scalar controls rotation first letter, vector length number base letters. code vector expansion code. left side corresponds higher levels (top-level) curve right side corresponds lower level (bottom-level) curve. value can set vector e.g. c(1, 2, 1), string e.g. \"121\", number e.g. 121. rot Rotation seed sequence, measured polar coordinate system, degrees. flip setting sfc_peano() sfc_meander(). type type rules use? 1 SFC_RULES_4x4_MEANDER_1 2 SFC_RULES_4x4_MEANDER_2. p sfc_4x4_meander object.","code":""},{"path":"/reference/sfc_4x4_meander.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"4x4 space-filling curves in meander type — sfc_4x4_meander","text":"extension 3x3 Meander curves mode 4. simplicity, supports /R/L base patterns.","code":""},{"path":"/reference/sfc_4x4_meander.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"4x4 space-filling curves in meander type — sfc_4x4_meander","text":"","code":"draw_multiple_curves(     sfc_4x4_meander(\"I\", \"11\", type = 1),     sfc_4x4_meander(\"I\", \"12\", type = 1),     sfc_4x4_meander(\"I\", \"11\", type = 2),     sfc_4x4_meander(\"I\", \"12\", type = 2),     nrow = 2 )  seed = paste(rep(paste0(\"R\", sapply(0:10, function(i) strrep(\"I\", i))), each = 2), collapse=\"\") sfc_4x4_meander(seed, 1) |> plot()  draw_rules_4x4_meander(type = 1)  draw_rules_4x4_meander(type = 2)"},{"path":"/reference/sfc_apply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply to every unit in the sfc_nxn curve — sfc_apply,sfc_nxn-method","title":"Apply to every unit in the sfc_nxn curve — sfc_apply,sfc_nxn-method","text":"Apply every unit sfc_nxn curve","code":""},{"path":"/reference/sfc_apply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply to every unit in the sfc_nxn curve — sfc_apply,sfc_nxn-method","text":"","code":"# S4 method for sfc_nxn sfc_apply(p, depth = 1, fun = function(x) x)"},{"path":"/reference/sfc_apply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply to every unit in the sfc_nxn curve — sfc_apply,sfc_nxn-method","text":"p sfc_nxn object. depth integer 0 level-1 curve. fun function argument x subunit curve. subunit sfc_nxn object contains current sub-sequence. function return sfc_seuqence object length x. function can take optional second argument index current subunit curve.","code":""},{"path":"/reference/sfc_apply.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply to every unit in the sfc_nxn curve — sfc_apply,sfc_nxn-method","text":"function mainly used flip subunits various levels curve, thus mainly Peano curve Meander curve. depth 0 corresponds complete curve. depth 1 corresponds nine first-level units, et al. Currently, sfc_apply() works curves single base pattern seed.","code":""},{"path":"/reference/sfc_apply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply to every unit in the sfc_nxn curve — sfc_apply,sfc_nxn-method","text":"","code":"p = sfc_peano(\"I\", level = 3) # flip the global curve draw_multiple_curves(     p,      sfc_apply(p, 0, sfc_flip_unit),     nrow = 1 )   # flip all the subunits on depth = 1 draw_multiple_curves(     p,      sfc_apply(p, 1, sfc_flip_unit),     nrow = 1 )   # flip all the subunits on depth = 2 draw_multiple_curves(     p,      sfc_apply(p, 2, sfc_flip_unit),     nrow = 1 )   # flip all level-1 patterns on the Peano curve to horizontal # only works on the lowest subunit,  p2 = sfc_apply(p, 2, function(x) {     if(level1_unit_orientation(x) == \"vertical\") {         sfc_flip_unit(x)     } else {         x     } }) # then on depth=1, only flip the unit with odd index p3 = sfc_apply(p2, 1, function(x, i) {     if(i %% 2 == 1) {         sfc_flip_unit(x)     } else {         x     } }) draw_multiple_curves(p2, p3, nrow = 1)   # flip all level-1 patterns to vertical p3 = sfc_apply(p, 2, function(x) {     if(level1_unit_orientation(x) == \"horizontal\") {         sfc_flip_unit(x)     } else {         x     } }) draw_multiple_curves(p, p3, nrow = 1)"},{"path":"/reference/sfc_base.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor of the sfc_base class — sfc_base","title":"Constructor of the sfc_base class — sfc_base","text":"Constructor sfc_base class","code":""},{"path":"/reference/sfc_base.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor of the sfc_base class — sfc_base","text":"","code":"sfc_base(   letter,   in_direction,   out_direction,   grob = NULL,   primary = TRUE,   open = TRUE )"},{"path":"/reference/sfc_base.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor of the sfc_base class — sfc_base","text":"letter single letter represent base pattern. in_direction direction segment enters point, measured polar coordinate system, degrees. out_direction direction segment leaves point, measured polar coordinate system, degrees. grob grid::grob() object base pattern. set, generated according in_direction out_direction. primary Currently, going forward, turning left turning right can set primary base patterns high-level patterns can built . open Can base pattern connected base patterns?","code":""},{"path":"/reference/sfc_base.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor of the sfc_base class — sfc_base","text":"sfc_base object.","code":""},{"path":"/reference/sfc_base.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructor of the sfc_base class — sfc_base","text":"\"base pattern\" designed single point also combination points form \"base curve\". However, currently, fixed single point base pattern. Currently, package supports 2x2 3x3 space-filling curves fills grids 2D space constructed Gaussian integers. curve expands, allow segments go forward, backward, left right. Thus following base patterns pre-defined package: BASE_I/BASE_J: go forward. BASE_R: turn right. BASE_L: turn left. BASE_U: go backward. BASE_B: leave start point start point closed. BASE_D: leave start point start point closed. BASE_P: return end point end point closed. BASE_Q: return end point end point closed. BASE_C: self-closed. base pattern determines final form curve.","code":""},{"path":"/reference/sfc_base.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor of the sfc_base class — sfc_base","text":"","code":"BASE_I #> Base: I, with 90 degrees in and 90 degrees out."},{"path":"/reference/sfc_expand.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand the curve to the next level — sfc_expand,sfc_hilbert-method","title":"Expand the curve to the next level — sfc_expand,sfc_hilbert-method","text":"Expand curve next level","code":""},{"path":"/reference/sfc_expand.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand the curve to the next level — sfc_expand,sfc_hilbert-method","text":"","code":"# S4 method for sfc_hilbert sfc_expand(p, code)  # S4 method for sfc_peano sfc_expand(p, code = 1, flip = FALSE)  # S4 method for sfc_meander sfc_expand(p, code, flip = FALSE)"},{"path":"/reference/sfc_expand.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand the curve to the next level — sfc_expand,sfc_hilbert-method","text":"p sfc_hilbert object. code Expansion code, single integer. flip Whethe flip level-1 units? value logical vector length one length p.","code":""},{"path":"/reference/sfc_expand.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand the curve to the next level — sfc_expand,sfc_hilbert-method","text":"object class input.","code":""},{"path":"/reference/sfc_expand.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expand the curve to the next level — sfc_expand,sfc_hilbert-method","text":"Hilbert curve Meander curve, long expansion code first base pattern sequence determinted, expansion codes base patterns sequence determined. Peano curve, code always 1. functions mainly used internally.","code":""},{"path":"/reference/sfc_expand.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand the curve to the next level — sfc_expand,sfc_hilbert-method","text":"","code":"p = sfc_hilbert(\"I\", 11) sfc_expand(p, 2) # I|211 #> An sfc_hilbert object. #>   Increase mode: 2 x 2 #>   Level: 3 #>   Expansion rule: Hilbert  #>  #> A sequence of 64 base patterns. #>   L(0)R(90)R(0)L(270)      L(0)R(90)R(0)I(270) #>   I(270)R(270)R(180)L(90)  I(180)L(180)L(270)R(0) #>   .... other 4 lines .... #>   R(90)L(0)L(90)I(180)     L(180)R(270)R(180)I(90) #>   I(90)R(90)R(0)L(270)     L(0)R(90)R(0)L(270) #>  #> Seed: A sequence of 1 base pattern. #>   I(0)   p = sfc_peano(\"I\", 11) sfc_expand(p, 2) # I|211 #> An sfc_peano object. #>   Increase mode: 3 x 3 #>   Level: 3 #>   Expansion rule: Peano  #>  #> A sequence of 729 base patterns. #>   I(0)J(0)R(0)R(270)  I(180)L(180)L(270)J(0) #>   I(0)J(0)I(0)L(0)    L(90)J(180)R(180)R(90) #>   .... other 88 lines .... #>   I(0)J(0)R(0)R(270)  I(180)L(180)L(270)J(0) #>   I(0)                 #>  #> Seed: A sequence of 1 base pattern. #>   I(0)   p = sfc_meander(\"I\", 11) sfc_expand(p, 2) # I|211 #> An sfc_meander object. #>   Increase mode: 3 x 3 #>   Level: 3 #>   Expansion rule: Meander  #>  #> A sequence of 729 base patterns. #>   L(0)I(90)R(90)I(0)  R(0)R(270)L(180)L(270) #>   I(0)L(0)I(90)R(90)  I(0)R(0)R(270)L(180) #>   .... other 88 lines .... #>   L(0)I(90)R(90)I(0)  R(0)R(270)L(180)L(270) #>   I(0)                 #>  #> Seed: A sequence of 1 base pattern. #>   I(0)"},{"path":"/reference/sfc_expand_by_rules.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand a sequence — sfc_expand_by_rules,sfc_rules,sfc_nxn-method","title":"Expand a sequence — sfc_expand_by_rules,sfc_rules,sfc_nxn-method","text":"Expand sequence","code":""},{"path":"/reference/sfc_expand_by_rules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand a sequence — sfc_expand_by_rules,sfc_rules,sfc_nxn-method","text":"","code":"# S4 method for sfc_rules,sfc_nxn sfc_expand_by_rules(p, seq, code = 1L, flip = FALSE, by = \"Cpp\")  # S4 method for sfc_rules,factor sfc_expand_by_rules(p, seq, code = 1L, flip = FALSE, by = \"Cpp\")  # S4 method for sfc_rules,character sfc_expand_by_rules(p, seq, code = 1L, flip = FALSE, by = \"Cpp\")"},{"path":"/reference/sfc_expand_by_rules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand a sequence — sfc_expand_by_rules,sfc_rules,sfc_nxn-method","text":"p sfc_rules object. seq sfc_nxn object objects. code expansion code. flip Peano curve Meander curves, unit can flipped without affecting parts curve. argument controls whether flip unit. Since currently works Peano curve Meander curve, flip logical vector length one length seq. Whether flips horizontally, vertically diagonal line automatically choosen. value flip can also function takes current curve argument. implementation? testing purpose.","code":""},{"path":"/reference/sfc_expand_by_rules.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand a sequence — sfc_expand_by_rules,sfc_rules,sfc_nxn-method","text":"seq sfc_nxn object, function also returns \"expanded\" sfc_nxn object. else returns sfc_sequence object.","code":""},{"path":"/reference/sfc_expand_by_rules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand a sequence — sfc_expand_by_rules,sfc_rules,sfc_nxn-method","text":"","code":"sfc_expand_by_rules(SFC_RULES_HILBERT, sfc_hilbert(\"I\")) #> An sfc_hilbert object. #>   Increase mode: 2 x 2 #>   Level: 1 #>   Expansion rule: Hilbert  #>  #> A sequence of 4 base patterns. #>   R(0)L(270)L(0)R(90)   #>  #> Seed: A sequence of 1 base pattern. #>   I(0)"},{"path":"/reference/sfc_flip_unit.html","id":null,"dir":"Reference","previous_headings":"","what":"Flip units — unit_orientation","title":"Flip units — unit_orientation","text":"Flip units","code":""},{"path":"/reference/sfc_flip_unit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flip units — unit_orientation","text":"","code":"unit_orientation(p, index = \"\")  # S4 method for sfc_nxn sfc_flip_unit(p, index = \"\", to = NULL)  # S4 method for sfc_unit sfc_flip_unit(p, bases)"},{"path":"/reference/sfc_flip_unit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flip units — unit_orientation","text":"p corresponding object. index string digits representing path hierarchy curve. left side corresponds top level right side corresponds bottom level curve. Hilbert curve, digits can 1-4, Peano Meander curves, digites can 1-9. See examples sfc_index(). value can also vector flipping applied sequence. orientation flip . specified unit already orientation, function returns original curve. bases Normally use BASE_LIST.","code":""},{"path":"/reference/sfc_flip_unit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flip units — unit_orientation","text":"unit_orientation() returns string one \"vertical\", \"horizontal\", \"diagonal_1\" \"diagonal_-1\". sfc_flip_unit returns sfc_nxn object.","code":""},{"path":"/reference/sfc_flip_unit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Flip units — unit_orientation","text":"unit_orientation(), first reduces unit level-1, checks orientation line connected -corner -corner. unit curve represented square block (2^k x 2^k Hilbert curve 3^k x 3^k Peano Meander curves, k 1 level curve). Hilbert curve, unit can flipped, symmetric, thus flipping Hilbert curve change form. flipping mainly applied Peano curve Meander curves. Peano curve allows flippings diagonals Meander curve allows flipping horizontally vertically. type flipping choosen automatically function. Currently, sfc_flip_unit() works curves single base pattern seed.","code":""},{"path":"/reference/sfc_flip_unit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flip units — unit_orientation","text":"","code":"p = sfc_meander(\"I\", 11) draw_multiple_curves(     p,      sfc_flip_unit(p, \"1\"), # bottom left     sfc_flip_unit(p, \"2\"), # bottom middle     sfc_flip_unit(p, \"3\"), # bottom right     nrow = 2)   p = sfc_peano(\"I\", level = 3) draw_multiple_curves(     p,      sfc_flip_unit(p, \"\"),     sfc_flip_unit(p, \"2\"),     sfc_flip_unit(p, \"2:1\"),     nrow = 2)   p = sfc_peano(\"I\", level = 2) draw_multiple_curves(p,      sfc_flip_unit(p, c(\"4\", \"7\")),     sfc_flip_unit(p, c(\"1\", \"2\", \"3\", \"5\", \"6\", \"8\", \"9\")),     nrow = 1)"},{"path":"/reference/sfc_generator.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a nxn curve based on expansion rules — sfc_generator","title":"Generate a nxn curve based on expansion rules — sfc_generator","text":"Generate nxn curve based expansion rules","code":""},{"path":"/reference/sfc_generator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a nxn curve based on expansion rules — sfc_generator","text":"","code":"sfc_generator(rules, name, envir = topenv(parent.frame()), verbose = TRUE)"},{"path":"/reference/sfc_generator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a nxn curve based on expansion rules — sfc_generator","text":"rules sfc_rules object. name Name curve. envir Environment functions exported . verbose Whether print messages?","code":""},{"path":"/reference/sfc_generator.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a nxn curve based on expansion rules — sfc_generator","text":"Two functions exported: sfc_{name}() draw_rules_{name}() simplicity, flipping supported yet.","code":""},{"path":"/reference/sfc_generator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a nxn curve based on expansion rules — sfc_generator","text":"","code":"UNIVERSE_4x4_PEANO = c(\"I\", \"R\", \"L\")  RULES_4x4_PEANO = list() RULES_4x4_PEANO[[\"I\"]][[1]] = sfc_unit(\"RIILLIIRRIILLIIR\", rot = 0, universe = UNIVERSE_4x4_PEANO) RULES_4x4_PEANO[[\"I\"]][[2]] = sfc_hflip(RULES_4x4_PEANO[[\"I\"]][[1]]) RULES_4x4_PEANO[[\"R\"]][[1]] = sfc_unit(\"IIIRRIILLIIRRIIL\", rot = 0, universe = UNIVERSE_4x4_PEANO)       RULES_4x4_PEANO[[\"R\"]][[2]] = sfc_rotate(sfc_unit(\"LIIRRIILLIIRRIII\",                                  rot = 270, universe = UNIVERSE_4x4_PEANO), 90) RULES_4x4_PEANO[[\"L\"]][[1]] = sfc_hflip(RULES_4x4_PEANO[[\"R\"]][[2]]) RULES_4x4_PEANO[[\"L\"]][[2]] = sfc_hflip(RULES_4x4_PEANO[[\"R\"]][[1]])  SFC_RULES_4x4_PEANO = sfc_rules(rules = RULES_4x4_PEANO,         name = \"Peano 4x4\",         bases = BASE_LIST[UNIVERSE_4x4_PEANO]) sfc_generator(SFC_RULES_4x4_PEANO, \"4x4_peano\") #> The following two functions are exported to the current top environment: #>   - sfc_4x4_peano() #>   - draw_rules_4x4_peano() draw_rules_4x4_peano()  sfc_4x4_peano(\"I\", 111) |> plot()"},{"path":"/reference/sfc_grob.html","id":null,"dir":"Reference","previous_headings":"","what":"The graphics object — sfc_grob,sfc_base-method","title":"The graphics object — sfc_grob,sfc_base-method","text":"graphics object","code":""},{"path":"/reference/sfc_grob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The graphics object — sfc_grob,sfc_base-method","text":"","code":"# S4 method for sfc_base sfc_grob(p)  # S4 method for sfc_sequence sfc_grob(   p,   bases = NULL,   extend = FALSE,   title = FALSE,   closed = FALSE,   lwd = 4,   col = NULL,   ... )  # S3 method for sfc_sequence plot(   x,   bases = NULL,   grid = FALSE,   extend = FALSE,   title = FALSE,   closed = FALSE,   ... )  # S4 method for sfc_nxn sfc_grob(   p,   bases = p@rules@bases,   extend = FALSE,   title = FALSE,   closed = FALSE,   ... )  # S3 method for sfc_nxn plot(x, grid = FALSE, extend = FALSE, title = FALSE, closed = FALSE, ...)  # S4 method for matrix sfc_grob(p, title = NULL, closed = FALSE, lwd = 4, col = NULL, ...)"},{"path":"/reference/sfc_grob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The graphics object — sfc_grob,sfc_base-method","text":"p corresponding object. bases list base patterns, consider use BASE_LIST. extend Whether add entering leaving segments? title Whether add title top plot? title constructed form initial_seed|expansion_code, e.g. |111. value string. closed Whether curve closed? lwd Line width. col Color segments. value NULL, uses \"Spectral\" color palettes. ... arguments passed grid::viewport() sfc_grob(). x corresponding object. grid Whether add grid lines plot?","code":""},{"path":"/reference/sfc_grob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The graphics object — sfc_grob,sfc_base-method","text":"grid::grob() object.","code":""},{"path":"/reference/sfc_grob.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The graphics object — sfc_grob,sfc_base-method","text":"p sfc_sequence p contains base patterns defined \"/J/R/L/U/B/D/P/Q/C\", default BASE_LIST automatically used bases. p sfc_nxn object, bases already stored p passed function automatically.","code":""},{"path":"/reference/sfc_grob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The graphics object — sfc_grob,sfc_base-method","text":"","code":"sfc_grob(BASE_I) #> gTree[GRID.gTree.4]  plot(sfc_hilbert(\"I\", \"11\"))  plot(sfc_hilbert(\"I\", \"11\"), extend = TRUE, title = TRUE, grid = TRUE)  plot(sfc_sequence(\"IIIRRR\"))"},{"path":"/reference/sfc_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Subunit in the curve — [.sfc_nxn","title":"Subunit in the curve — [.sfc_nxn","text":"Subunit curve","code":""},{"path":"/reference/sfc_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subunit in the curve — [.sfc_nxn","text":"","code":"# S3 method for sfc_nxn [(x, i, j, ..., drop = TRUE)  # S4 method for sfc_nxn sfc_index(p, index = \"\")"},{"path":"/reference/sfc_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subunit in the curve — [.sfc_nxn","text":"x sfc_nxn object. Numeric index character index representing hierarchy subunit curve. j value TRUE FALSE controls whether keep sfc_nxn class degenerate sfc_sequence class. ... Ignore. drop value TRUE FALSE controls whether keep sfc_nxn class degenerate sfc_sequence class. p sfc_nxn object. index string digits representing path hierarchy curve. left side corresponds top level right side corresponds bottom level curve. Hilbert curve, digits can 1-4, Peano Meander curves, digites can 1-9. Digits separated non-number characters, see examples.","code":""},{"path":"/reference/sfc_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Subunit in the curve — [.sfc_nxn","text":"sfc_index() works square curves (.e. curve single base letter seed.)","code":""},{"path":"/reference/sfc_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subunit in the curve — [.sfc_nxn","text":"","code":"p = sfc_hilbert(\"I\", \"11111\") p[\"3:2:1\"] #> A sequence of 16 base patterns. #>   I(270)L(270)L(0)R(90)   I(0)R(0)R(270)L(180) #>   L(270)R(0)R(270)I(180)  R(180)L(90)L(180)I(270) p[\"3:2:1\", TRUE] #> An sfc_hilbert object. #>   Increase mode: 2 x 2 #>   Level: 5 #>   Expansion rule: Hilbert  #>   A fragment from the original curve. #>  #> A sequence of 16 base patterns. #>   I(270)L(270)L(0)R(90)   I(0)R(0)R(270)L(180) #>   L(270)R(0)R(270)I(180)  R(180)L(90)L(180)I(270) #>  #> Seed: A sequence of 1 base pattern. #>   I(0)   # only for testing p = sfc_hilbert(\"I\", \"11111\") om = par(no.readonly = TRUE) par(mfrow = c(2, 2)) sfcurve:::test_sfc_index(p, \"3\") sfcurve:::test_sfc_index(p, \"3:2\") sfcurve:::test_sfc_index(p, \"3:2:1\") sfcurve:::test_sfc_index(p, \"3:2:1:1\")  par(om)  p = sfc_meander(\"I\", \"11111\") om = par(no.readonly = TRUE) par(mfrow = c(2, 2)) sfcurve:::test_sfc_index(p, \"7\") sfcurve:::test_sfc_index(p, \"7:5\") sfcurve:::test_sfc_index(p, \"7:5:9\") sfcurve:::test_sfc_index(p, \"7:5:9:2\")  par(om)"},{"path":"/reference/sfc_is_compatible.html","id":null,"dir":"Reference","previous_headings":"","what":"Whether two sfc_sequence objects are compatible — sfc_is_compatible,sfc_sequence,sfc_sequence-method","title":"Whether two sfc_sequence objects are compatible — sfc_is_compatible,sfc_sequence,sfc_sequence-method","text":"Whether two sfc_sequence objects compatible","code":""},{"path":"/reference/sfc_is_compatible.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Whether two sfc_sequence objects are compatible — sfc_is_compatible,sfc_sequence,sfc_sequence-method","text":"","code":"# S4 method for sfc_sequence,sfc_sequence sfc_is_compatible(p1, p2)  # S4 method for sfc_sequence,sfc_rules sfc_is_compatible(p1, p2)  # S4 method for sfc_rules,sfc_sequence sfc_is_compatible(p1, p2)"},{"path":"/reference/sfc_is_compatible.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Whether two sfc_sequence objects are compatible — sfc_is_compatible,sfc_sequence,sfc_sequence-method","text":"p1 sfc_sequence object. p2 sfc_sequence object.","code":""},{"path":"/reference/sfc_is_compatible.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Whether two sfc_sequence objects are compatible — sfc_is_compatible,sfc_sequence,sfc_sequence-method","text":"function compares whether two universe base pattern sets identical. Note order universe base patterns also identical.","code":""},{"path":"/reference/sfc_is_compatible.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Whether two sfc_sequence objects are compatible — sfc_is_compatible,sfc_sequence,sfc_sequence-method","text":"","code":"p1 = sfc_hilbert(\"I\") p2 = sfc_hilbert(\"R\") sfc_is_compatible(p1, p2) #> [1] TRUE  p1 = sfc_sequence(\"ABC\") p2 = sfc_sequence(\"DEF\") sfc_is_compatible(p1, p2) #> [1] FALSE"},{"path":"/reference/sfc_level.html","id":null,"dir":"Reference","previous_headings":"","what":"The level of the curve — sfc_level,sfc_nxn-method","title":"The level of the curve — sfc_level,sfc_nxn-method","text":"level curve","code":""},{"path":"/reference/sfc_level.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The level of the curve — sfc_level,sfc_nxn-method","text":"","code":"# S4 method for sfc_nxn sfc_level(p)"},{"path":"/reference/sfc_level.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The level of the curve — sfc_level,sfc_nxn-method","text":"p sfc_nxn object.","code":""},{"path":"/reference/sfc_level.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The level of the curve — sfc_level,sfc_nxn-method","text":"integer.","code":""},{"path":"/reference/sfc_level.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The level of the curve — sfc_level,sfc_nxn-method","text":"","code":"p = sfc_hilbert(\"I\", \"11\") sfc_level(p) #> [1] 2  p = sfc_hilbert(\"I\", \"1111\") sfc_level(p) #> [1] 4"},{"path":"/reference/sfc_mode.html","id":null,"dir":"Reference","previous_headings":"","what":"The mode of the curve — sfc_mode,sfc_nxn-method","title":"The mode of the curve — sfc_mode,sfc_nxn-method","text":"mode curve","code":""},{"path":"/reference/sfc_mode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The mode of the curve — sfc_mode,sfc_nxn-method","text":"","code":"# S4 method for sfc_nxn sfc_mode(p)  # S4 method for sfc_rules sfc_mode(p)"},{"path":"/reference/sfc_mode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The mode of the curve — sfc_mode,sfc_nxn-method","text":"p corresponding object.","code":""},{"path":"/reference/sfc_mode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The mode of the curve — sfc_mode,sfc_nxn-method","text":"","code":"p = sfc_hilbert(\"I\", \"1\") sfc_mode(p) #> [1] 2 p = sfc_peano(\"I\", \"1\") sfc_mode(p) #> [1] 3 sfc_mode(SFC_RULES_HILBERT) #> [1] 2 sfc_mode(SFC_RULES_PEANO) #> [1] 3"},{"path":"/reference/sfc_previous_point.html","id":null,"dir":"Reference","previous_headings":"","what":"The previous and the next point — sfc_previous_point,sfc_base-method","title":"The previous and the next point — sfc_previous_point,sfc_base-method","text":"previous next point","code":""},{"path":"/reference/sfc_previous_point.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The previous and the next point — sfc_previous_point,sfc_base-method","text":"","code":"# S4 method for sfc_base sfc_previous_point(p, x, rot, length = 1)  # S4 method for sfc_base sfc_next_point(p, x, rot, length = 1)"},{"path":"/reference/sfc_previous_point.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The previous and the next point — sfc_previous_point,sfc_base-method","text":"p sfc_base object. x coordinate current point. rot Rotation current point. length Length segment previous/next point current point.","code":""},{"path":"/reference/sfc_previous_point.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The previous and the next point — sfc_previous_point,sfc_base-method","text":"vector length two.","code":""},{"path":"/reference/sfc_previous_point.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The previous and the next point — sfc_previous_point,sfc_base-method","text":"","code":"sfc_previous_point(BASE_R, c(0, 0), 0) #>              [,1] [,2] #> [1,] -1.83697e-16   -1 sfc_previous_point(BASE_R, c(0, 0), 90) #>      [,1]          [,2] #> [1,]    1 -2.449294e-16 sfc_previous_point(BASE_R, c(0, 0), 180) #>              [,1] [,2] #> [1,] 3.061617e-16    1 sfc_previous_point(BASE_R, c(1, 0), 0) #>      [,1] [,2] #> [1,]    1   -1 sfc_previous_point(BASE_R, c(1, 0), 90) #>      [,1]          [,2] #> [1,]    2 -2.449294e-16 sfc_previous_point(BASE_R, c(1, 0), 180) #>      [,1] [,2] #> [1,]    1    1 sfc_next_point(BASE_R, c(0, 0), 0) #>      [,1] [,2] #> [1,]    1    0 sfc_next_point(BASE_R, c(0, 0), 90) #>              [,1] [,2] #> [1,] 6.123234e-17    1 sfc_next_point(BASE_R, c(0, 0), 180) #>      [,1]         [,2] #> [1,]   -1 1.224647e-16 sfc_next_point(BASE_R, c(1, 0), 0) #>      [,1] [,2] #> [1,]    2    0 sfc_next_point(BASE_R, c(1, 0), 90) #>      [,1] [,2] #> [1,]    1    1 sfc_next_point(BASE_R, c(1, 0), 180) #>      [,1]         [,2] #> [1,]    0 1.224647e-16"},{"path":"/reference/sfc_reduce.html","id":null,"dir":"Reference","previous_headings":"","what":"Reduce a curve — sfc_reduce,sfc_nxn-method","title":"Reduce a curve — sfc_reduce,sfc_nxn-method","text":"Reduce curve","code":""},{"path":"/reference/sfc_reduce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reduce a curve — sfc_reduce,sfc_nxn-method","text":"","code":"# S4 method for sfc_nxn sfc_reduce(p, to = sfc_level(p) - 1)  # S4 method for matrix sfc_reduce(p, to = level - 1)  add_base_structure(gb, level = 1)"},{"path":"/reference/sfc_reduce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reduce a curve — sfc_reduce,sfc_nxn-method","text":"p sfc_nxn object. level reduce ? Value 1 sfc_level(p) - 1. gb grob object returned sfc_grob() sfc_nxn object sfc_grob() internally applied. level level unit.","code":""},{"path":"/reference/sfc_reduce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reduce a curve — sfc_reduce,sfc_nxn-method","text":"two-column matrix coordinates reduced curve.","code":""},{"path":"/reference/sfc_reduce.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reduce a curve — sfc_reduce,sfc_nxn-method","text":"reduction applied coordinates points. add_base_structure() adds base structure certain level curve.","code":""},{"path":"/reference/sfc_reduce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reduce a curve — sfc_reduce,sfc_nxn-method","text":"","code":"p = sfc_peano(\"I\", level = 3) draw_multiple_curves(     p,      sfc_reduce(p, 2),      sfc_reduce(p, 1),      nrow = 1)  p = hilbert_curve(level = 4) draw_multiple_curves(     p,      sfc_reduce(p, 3),      sfc_reduce(p, 2),      nrow = 1)  p = hilbert_curve(3) draw_multiple_curves(     add_base_structure(p, level = 1),     add_base_structure(p, level = 2),     nrow = 1 )"},{"path":"/reference/sfc_rules.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor of the sfc_rules class — sfc_rules","title":"Constructor of the sfc_rules class — sfc_rules","text":"Constructor sfc_rules class","code":""},{"path":"/reference/sfc_rules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor of the sfc_rules class — sfc_rules","text":"","code":"sfc_rules(rules, bases, flip = list(), name = \"sfc_rules\")"},{"path":"/reference/sfc_rules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor of the sfc_rules class — sfc_rules","text":"rules list rules. bases list base patterns. flip list rules. \"flipped\" version rules. name self-defined string.","code":""},{"path":"/reference/sfc_rules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructor of the sfc_rules class — sfc_rules","text":"mainly used internally. rules two-level list. format rules[[ base ]][[ expansion_code ]] = sfc_unit(). following example define expansion rules th Hilbert curve:   level-0 base pattern, [[1]] corresponds first form expansion level-1, value assigned sfc_unit() object basically list base patterns. also need provide base patterns define extend curve. list base patterns assigned bases argument. example, set bases :   e.g. BASE_I pre-defined base pattern sfc_base class. following pre-defined rules: SFC_RULES_HILBERT SFC_RULES_PEANO SFC_RULES_MEANDER SFC_RULES_3x3_COMBINED SFC_RULES_4x4_MEANDER_1 SFC_RULES_4x4_MEANDER_2 Check https://github.com/jokergoo/sfcurve/blob/master/R/zz_global.R#L155 see pre-defined rules constructed.","code":"UNIVERSE_HILBERT = c(\"I\", \"R\", \"L\", \"U\", \"B\", \"D\", \"P\", \"Q\", \"C\") RULES_HILBERT = list() RULES_HILBERT[[\"I\"]][[1]] = sfc_unit(c(\"R\", \"L\", \"L\", \"R\"), rot = 0, universe = UNIVERSE_HILBERT) list(\"I\" = BASE_I, \"R\" = BASE_R, \"L\" = BASE_L, \"U\" = BASE_U, ...)"},{"path":"/reference/sfc_segments.html","id":null,"dir":"Reference","previous_headings":"","what":"Coordinates of the points on the curve — sfc_segments,sfc_nxn-method","title":"Coordinates of the points on the curve — sfc_segments,sfc_nxn-method","text":"Coordinates points curve","code":""},{"path":"/reference/sfc_segments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coordinates of the points on the curve — sfc_segments,sfc_nxn-method","text":"","code":"# S4 method for sfc_nxn sfc_segments(p, bases = p@rules@bases, start = c(0, 0), ...)  # S4 method for sfc_sequence sfc_segments(p, bases = NULL, start = c(0, 0), by = \"Cpp\")"},{"path":"/reference/sfc_segments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coordinates of the points on the curve — sfc_segments,sfc_nxn-method","text":"p sfc_nxn sfc_sequence object. bases list base patterns, consider use BASE_LIST. start Coordinate start point. ... argument. implementation? testing purpose.","code":""},{"path":"/reference/sfc_segments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coordinates of the points on the curve — sfc_segments,sfc_nxn-method","text":"two-column matrix coordinates points curve.","code":""},{"path":"/reference/sfc_segments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coordinates of the points on the curve — sfc_segments,sfc_nxn-method","text":"sfc_segments() sfc_sequence object, bases set, uses BASE_LIST internally. Make sure sequence contains pre-defined base patterns.","code":""},{"path":"/reference/sfc_segments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coordinates of the points on the curve — sfc_segments,sfc_nxn-method","text":"","code":"p = sfc_hilbert(\"I\", \"11\") loc = sfc_segments(p) plot(loc, type = \"l\", asp = 1)"},{"path":"/reference/sfc_sequence.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor of the sfc_sequence class — sfc_sequence","title":"Constructor of the sfc_sequence class — sfc_sequence","text":"Constructor sfc_sequence class","code":""},{"path":"/reference/sfc_sequence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor of the sfc_sequence class — sfc_sequence","text":"","code":"sfc_sequence(seq, rot = 0L, universe = NULL)  sfc_seed(seq, rot = 0L, universe = NULL)  sfc_unit(seq, rot = 0L, universe = NULL)"},{"path":"/reference/sfc_sequence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor of the sfc_sequence class — sfc_sequence","text":"seq sequence base patterns. value can vector letters single string. rot corresponding rotations base patterns. length one sequence contains R/L/(right/left/forward), rot controls rotation first base pattern rotations remaining base patterns sequence automatically calculated. universe universe base patterns. vector letters.","code":""},{"path":"/reference/sfc_sequence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructor of the sfc_sequence class — sfc_sequence","text":"funtion low-level. Normally, users need directly use constructor. sfc_seed class sfc_sequence class. used specifically \"seed sequence\" generating curves. sfc_unit class also inherits sfc_sequence class one additionally slot: corner. used specifically defining expansion rules.","code":""},{"path":"/reference/sfc_sequence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor of the sfc_sequence class — sfc_sequence","text":"","code":"sfc_sequence(\"ABCD\", rot = c(0, 90, 180, 270), universe = c(\"A\", \"B\", \"C\", \"D\")) #> A sequence of 4 base patterns. #>   A(0)B(90)C(180)D(270)"},{"path":"/reference/sfc_transformation.html","id":null,"dir":"Reference","previous_headings":"","what":"Transformations of a sequence — sfc_rotate,sfc_sequence-method","title":"Transformations of a sequence — sfc_rotate,sfc_sequence-method","text":"Transformations sequence","code":""},{"path":"/reference/sfc_transformation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transformations of a sequence — sfc_rotate,sfc_sequence-method","text":"","code":"# S4 method for sfc_sequence sfc_rotate(p, rot)  # S3 method for sfc_sequence ^(e1, e2)  # S4 method for sfc_sequence sfc_hflip(p, fix_ends = FALSE, bases = NULL)  # S4 method for sfc_sequence sfc_vflip(p, fix_ends = FALSE, bases = NULL)  # S4 method for sfc_sequence sfc_dflip(p, slop = 1, fix_ends = FALSE, bases = NULL)  # S4 method for sfc_sequence sfc_reverse(p)  # S3 method for sfc_sequence rev(x)"},{"path":"/reference/sfc_transformation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transformations of a sequence — sfc_rotate,sfc_sequence-method","text":"p sfc_sequence object. rot Rotation measured polar coordinate system, degrees. e1 sfc_sequence object. e2 rotation. fix_ends Whether keep orientation rotations starting ending base patterns? bases list base patterns, consider use BASE_LIST. used fix_ends = TRUE. slop Slop diagonal. x sfc_sequence object.","code":""},{"path":"/reference/sfc_transformation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transformations of a sequence — sfc_rotate,sfc_sequence-method","text":"sfc_sequence object.","code":""},{"path":"/reference/sfc_transformation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transformations of a sequence — sfc_rotate,sfc_sequence-method","text":"sfc_rotate() ^() rotate base pattern. sfc_hflip() flips sequence horizontally. sfc_vflip() flips sequence vertically. sfc_dflip() flips sequence diagonal line (slop 1 -1).","code":""},{"path":"/reference/sfc_transformation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transformations of a sequence — sfc_rotate,sfc_sequence-method","text":"","code":"p = sfc_meander(\"R\", 2, rot = -90) draw_multiple_curves(     p,      sfc_hflip(p),      sfc_hflip(p, fix_ends = TRUE),      nrow = 1)  p = sfc_meander(\"L\", 2, rot = -90) draw_multiple_curves(     p,      sfc_vflip(p),      sfc_vflip(p, fix_ends = TRUE),      nrow = 1)  p = sfc_peano(\"I\", 2) draw_multiple_curves(     p,      sfc_dflip(p, 1),      sfc_dflip(p, 1, fix_ends = TRUE),      nrow = 1)"},{"path":"/reference/sfc_universe.html","id":null,"dir":"Reference","previous_headings":"","what":"The universe base pattern set — sfc_universe,sfc_rules-method","title":"The universe base pattern set — sfc_universe,sfc_rules-method","text":"universe base pattern set","code":""},{"path":"/reference/sfc_universe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The universe base pattern set — sfc_universe,sfc_rules-method","text":"","code":"# S4 method for sfc_rules sfc_universe(p)  # S4 method for sfc_sequence sfc_universe(p)"},{"path":"/reference/sfc_universe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The universe base pattern set — sfc_universe,sfc_rules-method","text":"p corresponding object.","code":""},{"path":"/reference/sfc_universe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The universe base pattern set — sfc_universe,sfc_rules-method","text":"vector base patterns.","code":""},{"path":"/reference/sfc_universe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The universe base pattern set — sfc_universe,sfc_rules-method","text":"","code":"sfc_universe(SFC_RULES_HILBERT) #> [1] \"I\" \"R\" \"L\" \"U\" \"B\" \"D\" \"P\" \"Q\" \"C\" sfc_universe(SFC_RULES_PEANO) #> [1] \"I\" \"J\" \"R\" \"L\""},{"path":"/reference/sfc_validate.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate the sequence — sfc_validate,sfc_sequence-method","title":"Validate the sequence — sfc_validate,sfc_sequence-method","text":"Validate sequence","code":""},{"path":"/reference/sfc_validate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate the sequence — sfc_validate,sfc_sequence-method","text":"","code":"# S4 method for sfc_sequence sfc_validate(p, by = \"sfc_hilbert\")  # S4 method for character sfc_validate(p, by = \"sfc_hilbert\")"},{"path":"/reference/sfc_validate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate the sequence — sfc_validate,sfc_sequence-method","text":"p sfc_sequence object character string. character string, rotations taken zeros. One sfc_hilbert, sfc_peano sfc_meander.","code":""},{"path":"/reference/sfc_validate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate the sequence — sfc_validate,sfc_sequence-method","text":"mainly used validate seed sequence whether follow forward-left-right rule.","code":""},{"path":"/reference/sfc_validate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate the sequence — sfc_validate,sfc_sequence-method","text":"","code":"try(sfc_validate(\"LLLLL\")) #> Error : Crossing is not allowed in the sequence. try(sfc_validate(sfc_sequence(\"IIIII\", rot = c(0, 90, 180, 270, 0),          universe = sfc_universe(SFC_RULES_HILBERT)))) #> Error : Crossing is not allowed in the sequence."},{"path":"/reference/sfcurve-package.html","id":null,"dir":"Reference","previous_headings":"","what":"sfcurve: 2x2, 3x3 and nxn Space-Filling Curves — sfcurve-package","title":"sfcurve: 2x2, 3x3 and nxn Space-Filling Curves — sfcurve-package","text":"Implementation possible forms 2x2 3x3 space-filling curves, .e., generalized forms Hilbert curve https://en.wikipedia.org/wiki/Hilbert_curve, Peano curve https://en.wikipedia.org/wiki/Peano_curve Peano curve meander type (Figure 5 https://eudml.org/doc/141086). generates nxn curves expanded specific level-1 units. also implements H-curve three-dimensional Hilbert curve.","code":""},{"path":"/reference/sfcurve-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"sfcurve: 2x2, 3x3 and nxn Space-Filling Curves — sfcurve-package","text":"Please go package's website: https://jokergoo.github.io/sfcurve details.","code":""},{"path":[]},{"path":"/reference/sfcurve-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"sfcurve: 2x2, 3x3 and nxn Space-Filling Curves — sfcurve-package","text":"Maintainer: Zuguang Gu z.gu@dkfz.de (ORCID)","code":""},{"path":"/reference/show.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the object — show,sfc_base-method","title":"Print the object — show,sfc_base-method","text":"Print object","code":""},{"path":"/reference/show.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the object — show,sfc_base-method","text":"","code":"# S4 method for sfc_base show(object)  # S4 method for sfc_nxn show(object)  # S4 method for sfc_rules show(object)  # S4 method for sfc_sequence show(object)"},{"path":"/reference/show.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the object — show,sfc_base-method","text":"object corresponding object.","code":""},{"path":"/reference/spacefilling.html","id":null,"dir":"Reference","previous_headings":"","what":"Create space-filling curves — sfc_hilbert","title":"Create space-filling curves — sfc_hilbert","text":"Create space-filling curves","code":""},{"path":"/reference/spacefilling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create space-filling curves — sfc_hilbert","text":"","code":"sfc_hilbert(seed, code = integer(0), rot = 0L)  sfc_peano(seed, code = integer(0), rot = 0L, level = NULL, flip = FALSE)  sfc_meander(seed, code = integer(0), rot = 0L, flip = FALSE)"},{"path":"/reference/spacefilling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create space-filling curves — sfc_hilbert","text":"seed seed sequence. cases, seed sequence single base pattern, can specified single letter, rot controls initial rotation base pattern. also supports sequence one base patterns seed sequence. case, can specified string one base letters, rot can set single rotation scalar controls rotation first letter, vector length number base letters. code vector expansion code. left side corresponds top levels curve right side corresponds bottom level curve. value can set vector e.g. c(1, 2, 1), string e.g. \"121\", number e.g. 121. rot Rotation seed sequence, measured polar coordinate system, degrees. level Specifically sfc_peano(), since one expansion code 1, can also generated rep(1, level). flip Whether use \"flipped\" rules? Peano curve Meander curve, also \"fliiped\" version curve expansion rules. level expansion Peano curve Meander curve, point expands nine points 3x3 grids. Thus value flip can set logical vector length nine controls whether use flipped expansion corresponding unit. Besides \"1--9\" mode, flip can also set function acccepts number current points curve return logical vector length, .e. \"--*9\" mode.","code":""},{"path":"/reference/spacefilling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create space-filling curves — sfc_hilbert","text":"sfc_hilbert() returns sfc_hilbert object. sfc_peano() returns sfc_peano object. sfc_meander() returns sfc_meander object. three classes child classes sfc_nxn.","code":""},{"path":"/reference/spacefilling.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create space-filling curves — sfc_hilbert","text":"sfc_hilbert() generates Hilbert curve seed sequence. sfc_peano() generates Peano curve seed sequence. sfc_meander() generates Meander curve seed sequence.","code":""},{"path":"/reference/spacefilling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create space-filling curves — sfc_hilbert","text":"","code":"sfc_hilbert(\"I\", \"111\") |> plot()  sfc_hilbert(\"I\", \"111\", rot = 90) |> plot()  sfc_hilbert(\"IR\", \"111\", rot = 90) |> plot()  sfc_peano(\"I\", \"111\") |> plot()  sfc_peano(\"I\", \"111\",      flip = c(FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)) |> plot()  sfc_peano(\"IJ\", \"111\") |> plot()   sfc_peano(\"I\", level = 4, flip = function(p) {     p@rot %in% c(90, 270) }) |> plot(lwd = 1)   level = 4 sfc_peano(\"I\", level = level, flip = function(p) {      if(length(p) == 9^(level-1)) {          l = rep(FALSE, length(p))          ind = 1:9^2 + 9^2*rep(c(0, 2, 4, 6, 8), each = 9^2)          l[ind] = p@rot[ind] %in% c(90, 270)           ind = 1:9^2 + 9^2*rep(c(1, 3, 5, 7), each = 9^2)          l[ind] = p@rot[ind] %in% c(0, 180)           l     } else {          rep(FALSE, length(p))     } }) |> plot(lwd = 1)   sfc_meander(\"I\", \"111\") |> plot()  sfc_meander(\"I\", \"111\",      flip = c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE)) |> plot()  sfc_meander(\"IR\", \"111\") |> plot()"},{"path":"/reference/standard_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Various curves in their standard forms — hilbert_curve","title":"Various curves in their standard forms — hilbert_curve","text":"Various curves standard forms","code":""},{"path":"/reference/standard_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Various curves in their standard forms — hilbert_curve","text":"","code":"hilbert_curve(level = 2L, by = \"Cpp\")  moore_curve(level = 2L)  beta_omega_curve(level = 2L)  peano_curve(level = 2L, pattern = \"vvvvvvvvv\", by = \"Cpp\")  meander_curve(level = 2L, pattern = \"fffffffff\")  h_curve(iteration = 2L)"},{"path":"/reference/standard_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Various curves in their standard forms — hilbert_curve","text":"level Level curve. implementation? testing purpose. pattern orientation units level-2, .e. orientation 9 3x3 units. value string 9 letters \"v\"/\"h\" (vertical horizontal) Peano curve, \"f\"/\"b\" (forward backward) Meander curve. length string maximal 9. length smaller 9, stringis automatically recycled. iteration Number iterations.","code":""},{"path":"/reference/standard_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Various curves in their standard forms — hilbert_curve","text":"two-column matrix coordinates points curve.","code":""},{"path":"/reference/standard_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Various curves in their standard forms — hilbert_curve","text":"just special forms sfc_hilbert(), sfc_peano(), sfc_meander() sfc_h().","code":""},{"path":"/reference/standard_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Various curves in their standard forms — hilbert_curve","text":"","code":"hilbert_curve(2) #>       [,1] [,2] #>  [1,]    0    0 #>  [2,]    1    0 #>  [3,]    1    1 #>  [4,]    0    1 #>  [5,]    0    2 #>  [6,]    0    3 #>  [7,]    1    3 #>  [8,]    1    2 #>  [9,]    2    2 #> [10,]    2    3 #> [11,]    3    3 #> [12,]    3    2 #> [13,]    3    1 #> [14,]    2    1 #> [15,]    2    0 #> [16,]    3    0 draw_multiple_curves(     hilbert_curve(3),     hilbert_curve(4),     nrow = 1 )  draw_multiple_curves(     moore_curve(3),     moore_curve(4),     nrow = 1 )  draw_multiple_curves(     beta_omega_curve(3),     beta_omega_curve(4),     nrow = 1 )  draw_multiple_curves(     peano_curve(2),     peano_curve(3),     nrow = 1 )  draw_multiple_curves(     peano_curve(3, pattern = \"vh\"),     peano_curve(3, pattern = \"vvvhhhvvv\"),     nrow = 1 )  draw_multiple_curves(     meander_curve(2),     meander_curve(3),     nrow = 1 )  draw_multiple_curves(     meander_curve(3, pattern = \"fbfbfbfbf\"),     meander_curve(3, pattern = \"bbbbbffff\"),     nrow = 1 )  draw_multiple_curves(     h_curve(1),     h_curve(2),     nrow = 1, closed = TRUE )"},{"path":"/reference/transverse_path.html","id":null,"dir":"Reference","previous_headings":"","what":"All transverse paths of a sequence — all_transverse_paths","title":"All transverse paths of a sequence — all_transverse_paths","text":"transverse paths sequence","code":""},{"path":"/reference/transverse_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"All transverse paths of a sequence — all_transverse_paths","text":"","code":"all_transverse_paths(rules, p)  get_one_transverse_path(rules, p)  plot_transverse_paths(rules, p, type = c(\"all\", \"11|22\", \"12|21\"))"},{"path":"/reference/transverse_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"All transverse paths of a sequence — all_transverse_paths","text":"rules sfc_rules object. p sfc_sequence sequence. p rules universe base set. Please provide p small sequence total number transverse paths might huge. type value \"11|22\", highlights paths via 1-1/2-2 corners. value \"12|21\", highlights paths via 1-2/2-1 corners.","code":""},{"path":"/reference/transverse_path.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"All transverse paths of a sequence — all_transverse_paths","text":"Given input sequence rotations, all_transverse_paths() lists combinations expansion codes first letter last letter p (.e. possible transverse paths). get_one_transverse_path() returns one random transverse path.","code":""},{"path":"/reference/transverse_path.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"All transverse paths of a sequence — all_transverse_paths","text":"","code":"# expansion rules for the general 3x3 curves p = SFC_RULES_3x3_COMBINED@rules$I[[3]] get_one_transverse_path(SFC_RULES_3x3_COMBINED, p) #> [1] 4 3 2 3 3 2 1 2 4 get_one_transverse_path(SFC_RULES_3x3_COMBINED, p) #> [1] 1 1 3 1 2 3 3 4 3 get_one_transverse_path(SFC_RULES_3x3_COMBINED, p) #> [1] 2 2 2 3 3 2 1 4 1 get_one_transverse_path(SFC_RULES_3x3_COMBINED, p) #> [1] 3 2 2 1 4 1 3 4 1 #  p = SFC_RULES_3x3_COMBINED@rules$I[[3]] plot_transverse_paths(SFC_RULES_3x3_COMBINED, p)  plot_transverse_paths(SFC_RULES_3x3_COMBINED, p, type = \"11|22\")  plot_transverse_paths(SFC_RULES_3x3_COMBINED, p, type = \"12|21\")   # Hilbert curve p = sfc_hilbert(\"I\", 11) plot_transverse_paths(SFC_RULES_HILBERT, p)   # Peano curve p = sfc_peano(\"I\", 1) plot_transverse_paths(SFC_RULES_PEANO, p)   # Meander curve p = sfc_meander(\"I\", 1) plot_transverse_paths(SFC_RULES_MEANDER, p)"},{"path":"/reference/utility.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility functions — [.sfc_sequence","title":"Utility functions — [.sfc_sequence","text":"Utility functions","code":""},{"path":"/reference/utility.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility functions — [.sfc_sequence","text":"","code":"# S3 method for sfc_sequence [(x, i)  # S3 method for sfc_sequence [(x, i) <- value  # S3 method for sfc_sequence length(x)  # S3 method for sfc_sequence c(...)"},{"path":"/reference/utility.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility functions — [.sfc_sequence","text":"x sfc_sequence object. Numeric index. value sfc_sequence object. ... list sfc_sequence objects arguments.","code":""},{"path":"/reference/utility.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Utility functions — [.sfc_sequence","text":"efficiency, c.sfc_sequence() check whether input sfc_sequence objects compatible.","code":""}]
